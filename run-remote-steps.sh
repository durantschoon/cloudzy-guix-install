#!/usr/bin/env bash
# run-remote-steps.sh — fetch N scripts from one repo and run them interactively

# BEGIN SHA256 REPLACEMENT
# SHA256 checksums for all warning and clean scripts across all platforms
# Generated by update-sha256.sh - run that script to regenerate these values
declare -A SHA256=(
  # cloudzy platform
  ["cloudzy/install/01-partition-warnings.sh"]="32b81097e203d0e9f6c011a8ea9b02a9d988107b3c8356b788a611a3d009e952"
  ["cloudzy/install/02-mount-bind-warnings.sh"]="bbe6b045f4ce8a66378825c2668b0a3de9c442fc1cc6e0708d4bb325c26797de"
  ["cloudzy/install/03-config-write-warnings.sh"]="c15c7748692bc2455e22db8e04e196b7f83fc41800140bd33311dc69c06d2cf8"
  ["cloudzy/install/04-system-init-warnings.sh"]="f9ce166f0b36201cc366ad224860f26f951bb228583704c2b9effdf7eb00a4ea"
  ["cloudzy/install/01-partition-clean.sh"]="f99bdab57a8ef7aa3f6ef83f563524a0fade6b22e07c4914ca58c3381bc05ec1"
  ["cloudzy/install/02-mount-bind-clean.sh"]="6289b50678e9b80fe26181da1400966642f6b12b94523bc3e53b0a7aba80f632"
  ["cloudzy/install/03-config-write-clean.sh"]="149c03c78650835bbddda5d47c6e6afa125bf5c0980278e0537789aaa969cff2"
  ["cloudzy/install/04-system-init-clean.sh"]="45f56ee0002df99f03670f6e59bfde33c2b2ed96ff167c833c02809f17f277f8"

  # framework platform
  ["framework/install/01-partition-warnings.sh"]="32b81097e203d0e9f6c011a8ea9b02a9d988107b3c8356b788a611a3d009e952"
  ["framework/install/02-mount-bind-warnings.sh"]="bbe6b045f4ce8a66378825c2668b0a3de9c442fc1cc6e0708d4bb325c26797de"
  ["framework/install/03-config-write-warnings.sh"]="c15c7748692bc2455e22db8e04e196b7f83fc41800140bd33311dc69c06d2cf8"
  ["framework/install/04-system-init-warnings.sh"]="f9ce166f0b36201cc366ad224860f26f951bb228583704c2b9effdf7eb00a4ea"
  ["framework/install/01-partition-clean.sh"]="f99bdab57a8ef7aa3f6ef83f563524a0fade6b22e07c4914ca58c3381bc05ec1"
  ["framework/install/02-mount-bind-clean.sh"]="6289b50678e9b80fe26181da1400966642f6b12b94523bc3e53b0a7aba80f632"
  ["framework/install/03-config-write-clean.sh"]="149c03c78650835bbddda5d47c6e6afa125bf5c0980278e0537789aaa969cff2"
  ["framework/install/04-system-init-clean.sh"]="45f56ee0002df99f03670f6e59bfde33c2b2ed96ff167c833c02809f17f277f8"

  # framework-dual platform
  ["framework-dual/install/01-partition-check-warnings.sh"]="d139a00815eb00637c808d8fa243c92b7b922639255b99c50ecbc40e12d4bff1"
  ["framework-dual/install/02-mount-existing-warnings.sh"]="3a67c43528660ced1e27040c31a16669e56ef6676811f53ac1ef71c534555fda"
  ["framework-dual/install/03-config-dual-boot-warnings.sh"]="689a61109a9da4a4dab494d201ff359c25dc7b61cdbf6a3bf1b7fc3156d872eb"
  ["framework-dual/install/04-system-init-warnings.sh"]="f9ce166f0b36201cc366ad224860f26f951bb228583704c2b9effdf7eb00a4ea"
  ["framework-dual/install/01-partition-check-clean.sh"]="5a72ac5478b3e83a9cd4a3acce160f78efabedb40eea6543760fda66e3ddb84b"
  ["framework-dual/install/02-mount-existing-clean.sh"]="88b350588411e7a2239c5849bb7b963037e8347e040efd0a6efaf1d21b1f339d"
  ["framework-dual/install/03-config-dual-boot-clean.sh"]="280831ca3d56e207391b6b9a33bde7990d7393586891a7cfdb723339c1d5c151"
  ["framework-dual/install/04-system-init-clean.sh"]="45f56ee0002df99f03670f6e59bfde33c2b2ed96ff167c833c02809f17f277f8"

)
# END SHA256 REPLACEMENT

set -euo pipefail  # Safety: exit on error, undefined vars, and pipeline failures
IFS=$'\n\t'

### --- CONFIG ---------------------------------------------------------------

# 1) Point to your repo. You can use a branch or PIN to a commit SHA.
OWNER_REPO="durantschoon/cloudzy-guix-install"
REF="${GUIX_INSTALL_REF:-v0.1.5}"  # Set GUIX_INSTALL_REF env var to override (e.g., "main" for debugging)
RAW_BASE="https://raw.githubusercontent.com/${OWNER_REPO}/${REF}"

# 2) Platform selection and script configuration
# Set GUIX_PLATFORM env var to choose platform (default: cloudzy)
PLATFORM="${GUIX_PLATFORM:-cloudzy}"

# Define script bases for each platform
declare -A PLATFORM_SCRIPTS=(
  ["cloudzy"]="
    cloudzy/install/01-partition
    cloudzy/install/02-mount-bind
    cloudzy/install/03-config-write
    cloudzy/install/04-system-init
  "
  ["framework"]="
    framework/install/01-partition
    framework/install/02-mount-bind
    framework/install/03-config-write
    framework/install/04-system-init
  "
  ["framework-dual"]="
    framework-dual/install/01-partition-check
    framework-dual/install/02-mount-existing
    framework-dual/install/03-config-dual-boot
    framework-dual/install/04-system-init
  "
)

# Validate platform selection
if [[ -z "${PLATFORM_SCRIPTS[$PLATFORM]:-}" ]]; then
  echo "Error: Unsupported platform '$PLATFORM'"
  echo "Supported platforms: ${!PLATFORM_SCRIPTS[*]}"
  echo "Set GUIX_PLATFORM environment variable to choose platform"
  exit 1
fi

# Set script bases for selected platform (strip whitespace and convert to array)
read -r -a SCRIPT_BASES <<< "$(echo ${PLATFORM_SCRIPTS[$PLATFORM]})"

echo "Selected platform: $PLATFORM"
echo "Script sequence: ${SCRIPT_BASES[*]}"
echo "DEBUG: Number of scripts: ${#SCRIPT_BASES[@]}"
echo "DEBUG: Individual elements:"
for i in "${!SCRIPT_BASES[@]}"; do
  echo "  [$i] = '${SCRIPT_BASES[$i]}'"
done

# 4) Where to store downloads & logs locally
WORKDIR="$(mktemp -d /tmp/run-steps.XXXXXX)"
LOGDIR="${WORKDIR}/logs"

# 5) Extra env for child scripts (edit if useful)
export TMPDIR="${TMPDIR:-/var/tmp}"
export GUIX_BUILD_OPTIONS="${GUIX_BUILD_OPTIONS:---max-jobs=1 --cores=1}"

### --- UTIL ----------------------------------------------------------------

msg(){ printf "\n\033[1;34m==> %s\033[0m\n" "$*"; }
warn(){ printf "\n\033[1;33m[warn]\033[0m %s\n" "$*"; }
err(){ printf "\n\033[1;31m[err]\033[0m  %s\n" "$*"; }

verify_required_vars(){ # verify_required_vars var1 var2 ...
  local missing_vars=()
  for var in "$@"; do
    if [[ -z "${!var:-}" ]]; then
      missing_vars+=("$var")
    fi
  done
  
  if [[ ${#missing_vars[@]} -gt 0 ]]; then
    err "Missing required environment variables:"
    printf "  - %s\n" "${missing_vars[@]}"
    return 1
  fi
  return 0
}

ask_yes(){
  # ask_yes "Prompt?" default_yes|default_no
  local prompt="$1" default="$2" ans
  if [[ "$default" == default_yes ]]; then
    read -r -p "$prompt [Y/n] " ans
    [[ -z "$ans" || "$ans" =~ ^[Yy]$ ]]
  else
    read -r -p "$prompt [y/N] " ans
    [[ "$ans" =~ ^[Yy]$ ]]
  fi
}

fetch_file(){ # fetch_file path/to/script
  local rel="$1"
  local dest="${WORKDIR}/${rel}"
  mkdir -p "$(dirname "$dest")"
  local url="${RAW_BASE}/${rel}"
  echo "DEBUG: Fetching URL: $url" >&2
  echo "DEBUG: RAW_BASE=$RAW_BASE" >&2
  echo "DEBUG: REF=$REF" >&2
  curl -fsSL "$url?$(date +%s)" -o "$dest" || { err "Download failed: $url"; return 1; }
  chmod +x "$dest"
  # Skip SHA256 verification when using main branch for debugging
  if [[ -n "${SHA256[$rel]:-}" ]] && [[ "$REF" != "main" ]]; then
    echo "${SHA256[$rel]}  ${dest}" | shasum -a 256 -c - >/dev/null 2>&1 || {
      err "SHA256 mismatch for $rel"; return 1; }
  fi
  # Only echo the path if everything succeeded
  if [[ -f "$dest" ]]; then
    echo "$dest"
  else
    err "File not found after download: $dest"
    return 1
  fi
}

run_step(){ # run_step local_script_path
  if [ "$#" -lt 1 ]; then
    err "run_step called without a script path"; return 1; fi
  local script="$1"
  local name="$(basename "$script")"
  mkdir -p "$LOGDIR"
  local log="${LOGDIR}/${name}.log"
  msg "Running ${name}"
  
  local old_stdout=$(mktemp)
  local old_stderr=$(mktemp)
  exec 3>&1 4>&2 # Save current stdout and stderr
  exec > >(tee "$log" >&3) 2> >(tee "$log" >&4) # Redirect to tee and original stdout/stderr
  
  local old_pipefail_setting
  if [[ "$(set -o | grep pipefail)" == "pipefail on" ]]; then
    old_pipefail_setting="on"
  else
    old_pipefail_setting="off"
  fi
  set -o pipefail
  
  . "$script" # Source the script
  local rc=$?
  
  if [[ "$old_pipefail_setting" == "off" ]]; then
    set +o pipefail
  fi
  
  exec 1>&3 2>&4 # Restore original stdout and stderr
  exec 3>&- 4>&- # Close saved file descriptors
  
  # Ensure log file is fully written before reading
  sync
  sleep 0.1
  
  msg "Exit status for ${name}: ${rc}"
  echo "Log saved to: $log"
  echo "---- last 40 lines ----"
  tail -n 40 "$log" || true
  echo "-----------------------"
  
  if ! ask_yes "Continue to next step?" default_yes; then
    warn "User chose to stop. Workdir: $WORKDIR"
    exit $rc
  fi
  return $rc
}

# Source-and-log runner for warning scripts so that exported variables persist
run_warning_step(){ # run_warning_step local_script_path
  if [ "$#" -lt 1 ]; then
    err "run_warning_step called without a script path"; return 1; fi
  local script="$1"
  local name="$(basename "$script")"
  mkdir -p "$LOGDIR"
  local log="${LOGDIR}/${name}.log"
  msg "Running ${name}"

  # Save original stdout/stderr
  exec 3>&1 4>&2
  # Redirect current shell stdout/stderr through tee for logging
  exec > >(tee "$log") 2>&1

  # Source the script in the current shell so 'export VAR=...' persists
  . "$script"
  local rc=$?

  # Restore stdout/stderr
  exec 1>&3 2>&4
  exec 3>&- 4>&-

  # Ensure log file is fully written before reading
  sync
  sleep 0.1

  msg "Exit status for ${name}: ${rc}"
  echo "Log saved to: $log"
  echo "---- last 40 lines ----"
  tail -n 40 "$log" || true
  echo "-----------------------"

  if ! ask_yes "Continue to next step?" default_yes; then
    warn "User chose to stop. Workdir: $WORKDIR"
    exit $rc
  fi
  return $rc
}

### --- MAIN ----------------------------------------------------------------

msg "Workdir: ${WORKDIR}"
msg "Fetching from: ${RAW_BASE}"

# Basic prereqs
command -v curl >/dev/null 2>&1 || { err "curl is required"; exit 1; }
mkdir -p "$WORKDIR" "$LOGDIR"

# Download shared library files first (required by install scripts)
msg "Fetching shared library files"
fetch_file "lib/common.sh" || { err "Failed to fetch lib/common.sh"; exit 1; }
fetch_file "lib/mirrors.sh" || { err "Failed to fetch lib/mirrors.sh"; exit 1; }
fetch_file "lib/runner-common.sh" || { err "Failed to fetch lib/runner-common.sh"; exit 1; }

# No need to clear variables - they're in main context

for base in "${SCRIPT_BASES[@]}"; do
  echo "DEBUG: Processing base='$base'" >&2
  warning_script="${base}-warnings.sh"
  clean_script="${base}-clean.sh"
  echo "DEBUG: warning_script='$warning_script'" >&2
  echo "DEBUG: clean_script='$clean_script'" >&2

  msg "Fetch ${warning_script}"
  warning_path="$(fetch_file "$warning_script")" || {
    err "Failed to fetch $warning_script"; exit 1; }
  
  msg "Fetch ${clean_script}"
  clean_path="$(fetch_file "$clean_script")" || {
    err "Failed to fetch $clean_script"; exit 1; }
  
  # Files should be immediately readable after download
  
  # Preview the clean script head (this is what users care about)
  echo "---- ${clean_script} (head) ----"
  sed -n '1,30p' "$clean_path"
  echo "-----------------------"
  
  if ! ask_yes "Run ${base} step now?" default_yes; then
    warn "Skipping ${base} per user request"
    continue
  fi
  
  # Run warning script first
  msg "Running warnings for ${base}"
  
  # Verify required variables for scripts that depend on previous steps
  case "$base" in
    "02-mount-bind"|"03-config-write")
      if ! verify_required_vars "ROOT" "EFI"; then
        err "Cannot run ${base} - required variables from previous step are missing"
        err "Make sure 01-partition step completed successfully"
        exit 1
      fi
      msg "Verified required variables: ROOT=$ROOT, EFI=$EFI"
      ;;
  esac
  
  # Source the warnings script so that any 'export VAR=...' persists for the clean script
  run_warning_step "$warning_path" || {
    warn "${warning_script} returned non-zero; stopping."
    exit 1
  }
  
  # Run clean script
  run_step "$clean_path"
  clean_rc=$?
  
  # Verify critical steps completed successfully
  case "$base" in
    "01-partition")
      if [[ $clean_rc -eq 0 ]]; then
        if ! verify_required_vars "DEVICE" "ROOT" "EFI"; then
          err "01-partition completed but required variables are missing"
          exit 1
        fi
        msg "✅ 01-partition completed successfully"
      else
        err "01-partition failed (exit code: $clean_rc) - cannot proceed"
        exit 1
      fi
      ;;
  esac
  
  # Warn if script returned non-zero but don't exit (for non-critical scripts)
  if [[ $clean_rc -ne 0 ]] && [[ "$base" != "01-partition" ]]; then
    warn "${clean_script} returned non-zero; you may want to stop."
  fi
done

msg "All done. Logs in: $LOGDIR"
