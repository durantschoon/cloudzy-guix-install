#!/usr/bin/env bash
# run-remote-steps.sh — fetch N scripts from one repo and run them interactively

# BEGIN SHA256 REPLACEMENT
# SHA256 checksums for all warning and clean scripts
# Generated by update-sha256.sh - run that script to regenerate these values
declare -A SHA256=(
  # Warning scripts
  ["01-partition-warnings.sh"]="32b81097e203d0e9f6c011a8ea9b02a9d988107b3c8356b788a611a3d009e952"
  ["02-mount-bind-warnings.sh"]="bbe6b045f4ce8a66378825c2668b0a3de9c442fc1cc6e0708d4bb325c26797de"
  ["03-config-write-warnings.sh"]="0c3b79012ae5130e9f256727a8a78973c2133f3cdd54dea458b8c54e48837111"
  ["04-system-init-warnings.sh"]="f9ce166f0b36201cc366ad224860f26f951bb228583704c2b9effdf7eb00a4ea"
  ["05-postinstall-console-warnings.sh"]="c5f212f705ca6aad6609152a619974b551aeb5fe972fe6c19171a8f534c3334c"
  ["06-postinstall-own-terminal-warnings.sh"]="36a6bbc23153b0e2b93464f61d920c3d8c28f3a601c2ad6f1a4eeb7ae5c4be7a"

  # Clean scripts
  ["01-partition-clean.sh"]="f99bdab57a8ef7aa3f6ef83f563524a0fade6b22e07c4914ca58c3381bc05ec1"
  ["02-mount-bind-clean.sh"]="de8722ff394355659e48f380065ab73ec1ef0184b119b3447be01cf1d6b05094"
  ["03-config-write-clean.sh"]="047c90cdc79f245fe85cc44bd8917cb51a00f40b2796f3be4d88f8e801c75403"
  ["04-system-init-clean.sh"]="986c8c59ced113ed48dee197cc414efad932a68113a2a56ae42acdde123438f9"
  ["05-postinstall-console-clean.sh"]="4c0f26e514245a58b3b0679f27293c304492a630099fe44cfd0cb1e6e6fc0c66"
  ["06-postinstall-own-terminal-clean.sh"]="21622f339aeff1a62a8088dedac64d5a1a7ee4a6f0761a9d0ac595e63740ad4a"
  ["test-final-clean.sh"]="171d39389bdde7f6714810698964a9638987c348e968891985bda0e698b2c132"
)
# END SHA256 REPLACEMENT

set -euo pipefail  # Safety: exit on error, undefined vars, and pipeline failures
IFS=$'\n\t'

### --- CONFIG ---------------------------------------------------------------

# 1) Point to your repo. You can use a branch or PIN to a commit SHA.
OWNER_REPO="durantschoon/cloudzy-guix-install"
REF="${GUIX_INSTALL_REF:-v0.1.5}"  # Set GUIX_INSTALL_REF env var to override (e.g., "main" for debugging)
RAW_BASE="https://raw.githubusercontent.com/${OWNER_REPO}/${REF}"

# 2) List the scripts (in order) relative to the repo root.
# Each script now has two parts: warnings and clean implementation
SCRIPT_BASES=(
  "01-partition"
  "02-mount-bind"
  "03-config-write"
  "04-system-init"
  "05-postinstall-console"
  "06-postinstall-own-terminal"
)

# 4) Where to store downloads & logs locally
WORKDIR="$(mktemp -d /tmp/run-steps.XXXXXX)"
LOGDIR="${WORKDIR}/logs"

# 5) Extra env for child scripts (edit if useful)
export TMPDIR="${TMPDIR:-/var/tmp}"
export GUIX_BUILD_OPTIONS="${GUIX_BUILD_OPTIONS:---max-jobs=1 --cores=1}"

### --- UTIL ----------------------------------------------------------------

msg(){ printf "\n\033[1;34m==> %s\033[0m\n" "$*"; }
warn(){ printf "\n\033[1;33m[warn]\033[0m %s\n" "$*"; }
err(){ printf "\n\033[1;31m[err]\033[0m  %s\n" "$*"; }

verify_required_vars(){ # verify_required_vars var1 var2 ...
  local missing_vars=()
  for var in "$@"; do
    if [[ -z "${!var:-}" ]]; then
      missing_vars+=("$var")
    fi
  done
  
  if [[ ${#missing_vars[@]} -gt 0 ]]; then
    err "Missing required environment variables:"
    printf "  - %s\n" "${missing_vars[@]}"
    return 1
  fi
  return 0
}

ask_yes(){
  # ask_yes "Prompt?" default_yes|default_no
  local prompt="$1" default="$2" ans
  if [[ "$default" == default_yes ]]; then
    read -r -p "$prompt [Y/n] " ans
    [[ -z "$ans" || "$ans" =~ ^[Yy]$ ]]
  else
    read -r -p "$prompt [y/N] " ans
    [[ "$ans" =~ ^[Yy]$ ]]
  fi
}

fetch_file(){ # fetch_file path/to/script
  local rel="$1"
  local dest="${WORKDIR}/${rel}"
  mkdir -p "$(dirname "$dest")"
  local url="${RAW_BASE}/${rel}"
  curl -fsSL "$url?$(date +%s)" -o "$dest" || { err "Download failed: $url"; return 1; }
  chmod +x "$dest"
  # Skip SHA256 verification when using main branch for debugging
  if [[ -n "${SHA256[$rel]:-}" ]] && [[ "$REF" != "main" ]]; then
    echo "${SHA256[$rel]}  ${dest}" | shasum -a 256 -c - >/dev/null 2>&1 || {
      err "SHA256 mismatch for $rel"; return 1; }
  fi
  # Only echo the path if everything succeeded
  if [[ -f "$dest" ]]; then
    echo "$dest"
  else
    err "File not found after download: $dest"
    return 1
  fi
}

run_step(){ # run_step local_script_path
  if [ "$#" -lt 1 ]; then
    err "run_step called without a script path"; return 1; fi
  local script="$1"
  local name="$(basename "$script")"
  mkdir -p "$LOGDIR"
  local log="${LOGDIR}/${name}.log"
  msg "Running ${name}"
  # Variables from previous scripts are directly available in main context
  
  # Run script directly (no subshell) - variables will be available in main context
  set -o pipefail
  bash "$script" 2>&1 | tee "$log"
  local rc=${PIPESTATUS[0]}
  set +o pipefail
  msg "Exit status for ${name}: ${rc}"
  echo "Log saved to: $log"
  # Show tail and offer to view all
  echo "---- last 40 lines ----"
  tail -n 40 "$log" || true
  echo "-----------------------"
  
  # Variables set by the script are directly available in main context
  
  if ! ask_yes "Continue to next step?" default_yes; then
    warn "User chose to stop. Workdir: $WORKDIR"
    exit $rc
  fi
  return $rc
}

# Source-and-log runner for warning scripts so that exported variables persist
run_warning_step(){ # run_warning_step local_script_path
  if [ "$#" -lt 1 ]; then
    err "run_warning_step called without a script path"; return 1; fi
  local script="$1"
  local name="$(basename "$script")"
  mkdir -p "$LOGDIR"
  local log="${LOGDIR}/${name}.log"
  msg "Running ${name} (sourced to persist exported vars)"

  # Save original stdout/stderr
  exec 3>&1 4>&2
  # Redirect current shell stdout/stderr through tee for logging
  exec > >(tee "$log") 2>&1

  # Source the script in the current shell so 'export VAR=...' persists
  . "$script"
  local rc=$?

  # Restore stdout/stderr
  exec 1>&3 2>&4
  exec 3>&- 4>&-

  msg "Exit status for ${name}: ${rc}"
  echo "Log saved to: $log"
  echo "---- last 40 lines ----"
  tail -n 40 "$log" || true
  echo "-----------------------"

  if ! ask_yes "Continue to next step?" default_yes; then
    warn "User chose to stop. Workdir: $WORKDIR"
    exit $rc
  fi
  return $rc
}

### --- MAIN ----------------------------------------------------------------

msg "Workdir: ${WORKDIR}"
msg "Fetching from: ${RAW_BASE}"

# Basic prereqs
command -v curl >/dev/null 2>&1 || { err "curl is required"; exit 1; }
mkdir -p "$WORKDIR" "$LOGDIR"

# No need to clear variables - they're in main context

for base in "${SCRIPT_BASES[@]}"; do
  warning_script="${base}-warnings.sh"
  clean_script="${base}-clean.sh"
  
  msg "Fetch ${warning_script}"
  warning_path="$(fetch_file "$warning_script")" || {
    err "Failed to fetch $warning_script"; exit 1; }
  
  msg "Fetch ${clean_script}"
  clean_path="$(fetch_file "$clean_script")" || {
    err "Failed to fetch $clean_script"; exit 1; }
  
  # Files should be immediately readable after download
  
  # Preview the clean script head (this is what users care about)
  echo "---- ${clean_script} (head) ----"
  sed -n '1,30p' "$clean_path"
  echo "-----------------------"
  
  if ! ask_yes "Run ${base} step now?" default_yes; then
    warn "Skipping ${base} per user request"
    continue
  fi
  
  # Run warning script first
  msg "Running warnings for ${base}"
  
  # Verify required variables for scripts that depend on previous steps
  case "$base" in
    "02-mount-bind"|"03-config-write")
      if ! verify_required_vars "ROOT" "EFI"; then
        err "Cannot run ${base} - required variables from previous step are missing"
        err "Make sure 01-partition step completed successfully"
        exit 1
      fi
      msg "Verified required variables: ROOT=$ROOT, EFI=$EFI"
      ;;
  esac
  
  # Source the warnings script so that any 'export VAR=...' persists for the clean script
  run_warning_step "$warning_path" || {
    warn "${warning_script} returned non-zero; stopping."
    exit 1
  }
  
  # Run clean script
  run_step "$clean_path"
  local clean_rc=$?
  
  # Verify critical steps completed successfully
  case "$base" in
    "01-partition")
      if [[ $clean_rc -eq 0 ]]; then
        if ! verify_required_vars "DEVICE" "ROOT" "EFI"; then
          err "01-partition completed but required variables are missing"
          exit 1
        fi
        msg "✅ 01-partition completed successfully"
      else
        err "01-partition failed (exit code: $clean_rc) - cannot proceed"
        exit 1
      fi
      ;;
  esac
  
  # Warn if script returned non-zero but don't exit (for non-critical scripts)
  if [[ $clean_rc -ne 0 ]] && [[ "$base" != "01-partition" ]]; then
    warn "${clean_script} returned non-zero; you may want to stop."
  fi
done

msg "All done. Logs in: $LOGDIR"
