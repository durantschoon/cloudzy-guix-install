#!/usr/bin/env bash
# run-remote-steps.sh — fetch N scripts from one repo and run them interactively

# BEGIN SHA256 REPLACEMENT
# SHA256 checksums for all warning and clean scripts
# Generated by update-sha256.sh - run that script to regenerate these values
declare -A SHA256=(
  # Warning scripts
  ["01-partition-warnings.sh"]="cbf59f6fb8ecf0029b79c99a0a7617e7979d117f8c8d8a567da4b570993a3e8c"
  ["02-mount-bind-warnings.sh"]="bbe6b045f4ce8a66378825c2668b0a3de9c442fc1cc6e0708d4bb325c26797de"
  ["03-config-write-warnings.sh"]="8b52859a651de1f33dc057f8b0ba24a1898587f98d70aa5e47af10367445c588"
  ["04-system-init-warnings.sh"]="f9ce166f0b36201cc366ad224860f26f951bb228583704c2b9effdf7eb00a4ea"
  ["05-postinstall-console-warnings.sh"]="c5f212f705ca6aad6609152a619974b551aeb5fe972fe6c19171a8f534c3334c"
  ["06-postinstall-own-terminal-warnings.sh"]="36a6bbc23153b0e2b93464f61d920c3d8c28f3a601c2ad6f1a4eeb7ae5c4be7a"

  # Clean scripts
  ["01-partition-clean.sh"]="7a1ac77001a39e22578f5201aea5c6488c53fe441b1da81e327fea72ff03f687"
  ["02-mount-bind-clean.sh"]="de8722ff394355659e48f380065ab73ec1ef0184b119b3447be01cf1d6b05094"
  ["03-config-write-clean.sh"]="047c90cdc79f245fe85cc44bd8917cb51a00f40b2796f3be4d88f8e801c75403"
  ["04-system-init-clean.sh"]="986c8c59ced113ed48dee197cc414efad932a68113a2a56ae42acdde123438f9"
  ["05-postinstall-console-clean.sh"]="4c0f26e514245a58b3b0679f27293c304492a630099fe44cfd0cb1e6e6fc0c66"
  ["06-postinstall-own-terminal-clean.sh"]="21622f339aeff1a62a8088dedac64d5a1a7ee4a6f0761a9d0ac595e63740ad4a"
)
# END SHA256 REPLACEMENT

set -euo pipefail  # Safety: exit on error, undefined vars, and pipeline failures
IFS=$'\n\t'

### --- CONFIG ---------------------------------------------------------------

# 1) Point to your repo. You can use a branch or PIN to a commit SHA.
OWNER_REPO="durantschoon/cloudzy-guix-install"
REF="${GUIX_INSTALL_REF:-v0.1.5}"  # Set GUIX_INSTALL_REF env var to override (e.g., "main" for debugging)
RAW_BASE="https://raw.githubusercontent.com/${OWNER_REPO}/${REF}"

# 2) List the scripts (in order) relative to the repo root.
# Each script now has two parts: warnings and clean implementation
SCRIPT_BASES=(
  "01-partition"
  "02-mount-bind"
  "03-config-write"
  "04-system-init"
  "05-postinstall-console"
  "06-postinstall-own-terminal"
)

# 4) Where to store downloads & logs locally
WORKDIR="$(mktemp -d /tmp/run-steps.XXXXXX)"
LOGDIR="${WORKDIR}/logs"

# 5) Extra env for child scripts (edit if useful)
export TMPDIR="${TMPDIR:-/var/tmp}"
export GUIX_BUILD_OPTIONS="${GUIX_BUILD_OPTIONS:---max-jobs=1 --cores=1}"

### --- UTIL ----------------------------------------------------------------

msg(){ printf "\n\033[1;34m==> %s\033[0m\n" "$*"; }
warn(){ printf "\n\033[1;33m[warn]\033[0m %s\n" "$*"; }
err(){ printf "\n\033[1;31m[err]\033[0m  %s\n" "$*"; }

verify_required_vars(){ # verify_required_vars var1 var2 ...
  local missing_vars=()
  for var in "$@"; do
    if [[ -z "${!var:-}" ]]; then
      missing_vars+=("$var")
    fi
  done
  
  if [[ ${#missing_vars[@]} -gt 0 ]]; then
    err "Missing required environment variables:"
    printf "  - %s\n" "${missing_vars[@]}"
    return 1
  fi
  return 0
}

wait_for_script_completion(){ # wait_for_script_completion script_name expected_vars...
  local script_name="$1"
  shift
  local expected_vars=("$@")
  local max_wait=30  # Maximum wait time in seconds
  local wait_time=0
  local completion_marker="/tmp/${script_name}-completion.marker"
  
  msg "Waiting for ${script_name} to complete and set variables..."
  
  while [[ $wait_time -lt $max_wait ]]; do
    # Check if completion marker exists
    if [[ -f "$completion_marker" ]]; then
      # Check if variables file exists and has content
      if [[ -f "/tmp/script_vars.sh" ]] && [[ -s "/tmp/script_vars.sh" ]]; then
        # Source the variables
        source "/tmp/script_vars.sh"
        
        # Check if all expected variables are present
        local all_present=true
        for var in "${expected_vars[@]}"; do
          if [[ -z "${!var:-}" ]]; then
            all_present=false
            break
          fi
        done
        
        if [[ "$all_present" == true ]]; then
          msg "✅ ${script_name} completed successfully - all variables present"
          return 0
        fi
      fi
    fi
    
    sleep 1
    ((wait_time++))
    echo -n "."
  done
  
  err "❌ Timeout waiting for ${script_name} to complete (${max_wait}s)"
  return 1
}
ask_yes(){
  # ask_yes "Prompt?" default_yes|default_no
  local prompt="$1" default="$2" ans
  if [[ "$default" == default_yes ]]; then
    read -r -p "$prompt [Y/n] " ans
    [[ -z "$ans" || "$ans" =~ ^[Yy]$ ]]
  else
    read -r -p "$prompt [y/N] " ans
    [[ "$ans" =~ ^[Yy]$ ]]
  fi
}

fetch_file(){ # fetch_file path/to/script
  local rel="$1"
  local dest="${WORKDIR}/${rel}"
  mkdir -p "$(dirname "$dest")"
  local url="${RAW_BASE}/${rel}"
  curl -fsSL "$url?$(date +%s)" -o "$dest" || { err "Download failed: $url"; return 1; }
  chmod +x "$dest"
  # Skip SHA256 verification when using main branch for debugging
  if [[ -n "${SHA256[$rel]:-}" ]] && [[ "$REF" != "main" ]]; then
    echo "${SHA256[$rel]}  ${dest}" | shasum -a 256 -c - >/dev/null 2>&1 || {
      err "SHA256 mismatch for $rel"; return 1; }
  fi
  # Only echo the path if everything succeeded
  if [[ -f "$dest" ]]; then
    echo "$dest"
  else
    err "File not found after download: $dest"
    return 1
  fi
}

run_step(){ # run_step local_script_path
  if [ "$#" -lt 1 ]; then
    err "run_step called without a script path"; return 1; fi
  local script="$1"
  local name="$(basename "$script")"
  mkdir -p "$LOGDIR"
  local log="${LOGDIR}/${name}.log"
  msg "Running ${name}"
  # Run in a clean subshell; preserve PATH for tiny ISOs
  # Source any existing variables from previous scripts
  if [[ -f "${WORKDIR}/script_vars.sh" ]]; then
    source "${WORKDIR}/script_vars.sh"
  fi
  # Also support scripts writing to /tmp/script_vars.sh directly
  if [[ -f "/tmp/script_vars.sh" ]]; then
    # Add a small delay to ensure file is fully written
    sleep 0.1
    source "/tmp/script_vars.sh"
    # keep a copy in WORKDIR for subsequent steps/logging continuity
    cp -f "/tmp/script_vars.sh" "${WORKDIR}/script_vars.sh" 2>/dev/null || true
  fi
  ( set -o pipefail; bash "$script" 2>&1 | tee "$log" )
  local rc=${PIPESTATUS[0]}
  msg "Exit status for ${name}: ${rc}"
  echo "Log saved to: $log"
  # Show tail and offer to view all
  echo "---- last 40 lines ----"
  tail -n 40 "$log" || true
  echo "-----------------------"
  
  # Ensure script variables are properly written and synced to disk
  if [[ -f "/tmp/script_vars.sh" ]]; then
    sync  # Force filesystem sync to ensure data is written to disk
    # Verify the file is readable and has content
    if [[ -r "/tmp/script_vars.sh" ]] && [[ -s "/tmp/script_vars.sh" ]]; then
      msg "Script variables file verified and synced to disk"
      # Source the variables into the main script context for verification
      source "/tmp/script_vars.sh"
    else
      warn "Script variables file may not be properly written"
    fi
  fi
  
  if ! ask_yes "Continue to next step?" default_yes; then
    warn "User chose to stop. Workdir: $WORKDIR"
    exit $rc
  fi
  return $rc
}

### --- MAIN ----------------------------------------------------------------

msg "Workdir: ${WORKDIR}"
msg "Fetching from: ${RAW_BASE}"

# Basic prereqs
command -v curl >/dev/null 2>&1 || { err "curl is required"; exit 1; }
mkdir -p "$WORKDIR" "$LOGDIR"

# Clear any existing script variables from previous runs
rm -f /tmp/script_vars.sh "${WORKDIR}/script_vars.sh"

for base in "${SCRIPT_BASES[@]}"; do
  warning_script="${base}-warnings.sh"
  clean_script="${base}-clean.sh"
  
  msg "Fetch ${warning_script}"
  warning_path="$(fetch_file "$warning_script")" || {
    err "Failed to fetch $warning_script"; exit 1; }
  
  msg "Fetch ${clean_script}"
  clean_path="$(fetch_file "$clean_script")" || {
    err "Failed to fetch $clean_script"; exit 1; }
  
  # Ensure files are fully written before reading
  sleep 0.5
  
  # Wait for files to be readable
  for script_path in "$warning_path" "$clean_path"; do
    echo "Checking if file is readable: $script_path"
    ls -la "$script_path" || echo "File not found or not accessible"
    timeout=30  # 30 second timeout
    count=0
    while [[ ! -r "$script_path" ]] && [[ $count -lt $timeout ]]; do
      echo "Waiting for file to be readable: $script_path (attempt $((count + 1))/$timeout)"
      sleep 1
      ((count++))
    done
    if [[ ! -r "$script_path" ]]; then
      err "Timeout waiting for file to be readable: $script_path"
      exit 1
    fi
  done
  
  # Preview the clean script head (this is what users care about)
  echo "---- ${clean_script} (head) ----"
  sed -n '1,30p' "$clean_path"
  echo "-----------------------"
  
  if ! ask_yes "Run ${base} step now?" default_yes; then
    warn "Skipping ${base} per user request"
    continue
  fi
  
  # Run warning script first
  msg "Running warnings for ${base}"
  
  # Verify required variables for specific scripts that depend on previous steps
  case "$base" in
    "02-mount-bind")
      if ! verify_required_vars "ROOT" "EFI"; then
        err "Cannot run ${base} - required variables from previous step are missing"
        err "Make sure 01-partition step completed successfully"
        exit 1
      fi
      msg "Verified required variables: ROOT=$ROOT, EFI=$EFI"
      ;;
    "03-config-write")
      if ! verify_required_vars "ROOT" "EFI"; then
        err "Cannot run ${base} - required variables from previous step are missing"
        err "Make sure 01-partition step completed successfully"
        exit 1
      fi
      msg "Verified required variables: ROOT=$ROOT, EFI=$EFI"
      ;;
  esac
  
  run_step "$warning_path" || {
    warn "${warning_script} returned non-zero; stopping."
    exit 1
  }
  
  # Run clean script
  run_step "$clean_path"
  local clean_rc=$?
  
  # Wait for script completion and verify variables for dependent scripts
  case "$base" in
    "01-partition")
      if [[ $clean_rc -eq 0 ]]; then
        if ! wait_for_script_completion "01-partition" "DEVICE" "ROOT" "EFI"; then
          err "01-partition step did not complete successfully"
          exit 1
        fi
      else
        err "01-partition step failed (exit code: $clean_rc) - cannot proceed"
        err "Please fix the partition issue and try again"
        exit 1
      fi
      ;;
  esac
  
  # Warn if script returned non-zero but don't exit (for non-critical scripts)
  if [[ $clean_rc -ne 0 ]] && [[ "$base" != "01-partition" ]]; then
    warn "${clean_script} returned non-zero; you may want to stop."
  fi
done

msg "All done. Logs in: $LOGDIR"
