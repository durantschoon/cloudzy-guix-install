{
  "custom_id": "convert-postinstall-recipes-add-development",
  "params": {
    "model": "claude-sonnet-4-5",
    "max_tokens": 8192,
    "messages": [
      {
        "role": "user",
        "content": "Convert this bash script to Guile Scheme following the documentation provided.\n\nREFERENCE DOCUMENTATION:\n\n# GUILE KNOWLEDGE BASE\n\n# Guile Development Knowledge Base\n\n**Purpose**: Central index for Guile Scheme development knowledge in this project.\n\n**Read this before**: Starting any new Guile script or modifying existing .scm files.\n\n---\n\n## Quick Navigation\n\n### ðŸ“š [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md)\nBest practices and design patterns for writing maintainable Guile code.\n\n**Topics:**\n- Module system usage\n- Separation of concerns (REPL/Script/Library)\n- Pure functional style\n- Tail recursion patterns\n- Incremental development\n- Code readability and naming\n- Abstraction levels\n- Performance optimization\n- Scheme conventions\n- Error handling\n\n**Read this**: When designing new functions or refactoring existing code.\n\n---\n\n### âš ï¸  [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md)\nCommon mistakes sorted by frequency (most common first).\n\n**Current top gotchas:**\n1. Missing SRFI-1 import (Count: 3)\n2. Wrong shebang for piped execution (Count: 2)\n3. Using macOS commands on Guix (Count: 2)\n4. Reading only first S-expression (Count: 1)\n5. Wrong invocation for piped scripts (Count: 1)\n\n**Read this**: When you encounter an error, or before writing similar code patterns.\n\n---\n\n## Guile Quick Reference (This Project)\n\n### Standard Shebang for Standalone Scripts\n\n**For regular scripts (executed directly):**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n**For scripts meant to be piped (bootstrap scripts):**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n### Essential Imports\n\n**Minimum for most scripts:**\n```scheme\n(use-modules (ice-9 popen)       ; Command execution\n             (ice-9 rdelim)      ; Line reading\n             (ice-9 format)      ; String formatting\n             (srfi srfi-1))      ; List processing\n```\n\n**For S-expression manipulation:**\n```scheme\n(use-modules (ice-9 pretty-print) ; Pretty-print S-exprs\n             (ice-9 match)        ; Pattern matching\n             (srfi srfi-1))       ; List functions\n```\n\n### Common Patterns\n\n**Reading all S-expressions from a file:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**Executing shell command and capturing output:**\n```scheme\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (values output status)))\n```\n\n**Pattern matching on S-expressions:**\n```scheme\n(use-modules (ice-9 match))\n\n(match expr\n  (('operating-system fields ...)\n   ;; Handle operating-system form\n   ...)\n  (('use-modules modules ...)\n   ;; Handle use-modules form\n   ...)\n  (else\n   ;; Default case\n   ...))\n```\n\n---\n\n## Testing Strategy\n\n### REPL-Driven Development\n\n1. Start Guile REPL: `guile`\n2. Load your module: `(load \"lib/my-script.scm\")`\n3. Test functions interactively\n4. Fix issues and reload\n5. Once working, extract to clean script\n\n### Integration Testing\n\n**For config manipulation:**\n```bash\n# Test with sample config file\nframework-dual/postinstall/tests/run-guile-tests.sh\n```\n\n**For bootstrap scripts:**\n```bash\n# Test in Docker environment\n./test-docker.sh test\n```\n\n---\n\n## File I/O Reference\n\n### Reading Files\n\n```scheme\n;; Read entire file as string\n(call-with-input-file \"path/to/file\" read-string)\n\n;; Read all S-expressions\n(call-with-input-file \"config.scm\"\n  (lambda (port)\n    (let loop ((exprs '()))\n      (let ((expr (read port)))\n        (if (eof-object? expr)\n            (reverse exprs)\n            (loop (cons expr exprs)))))))\n\n;; Read line by line\n(call-with-input-file \"path/to/file\"\n  (lambda (port)\n    (let loop ((lines '()))\n      (let ((line (read-line port)))\n        (if (eof-object? line)\n            (reverse lines)\n            (loop (cons line lines)))))))\n```\n\n### Writing Files\n\n```scheme\n;; Write string to file\n(call-with-output-file \"path/to/file\"\n  (lambda (port)\n    (display \"content\" port)))\n\n;; Pretty-print S-expression to file\n(call-with-output-file \"config.scm\"\n  (lambda (port)\n    (pretty-print expr port)))\n```\n\n---\n\n## Shell Integration\n\n### Running Commands\n\n```scheme\n;; Simple command execution (return status)\n(system \"ls -la\")  ; Returns exit code\n\n;; Execute with proper error handling\n(define (system* cmd)\n  (let ((status (system cmd)))\n    (zero? status)))\n\n;; Capture output\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (if (zero? status)\n        output\n        #f)))\n```\n\n### Platform-Specific Commands\n\n**ALWAYS use GNU coreutils on Guix:**\n- âœ… `sha256sum` (NOT `shasum`)\n- âœ… `md5sum` (NOT `md5`)\n- âœ… `stat` (NOT `gstat`)\n\nSee [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md#count-2-using-macos-commands-on-guix) for details.\n\n---\n\n## When to Use Guile vs Bash\n\n### Use Guile when:\n- Manipulating S-expressions (config.scm files)\n- Complex data transformations\n- Need proper error handling\n- Cross-platform script requirements\n\n### Use Bash when:\n- Simple file operations\n- Gluing together CLI tools\n- Quick one-liners\n- Temporary helper scripts\n\n### Use Guile from Bash:\n```bash\n# Call Guile helper from bash\nguile_add_service() {\n  local module=\"$1\"\n  local service=\"$2\"\n\n  guile --no-auto-compile -s lib/guile-config-helper.scm \\\n    add-service /etc/config.scm \"$module\" \"$service\"\n}\n```\n\n---\n\n## Resources\n\n### Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Learning Resources\n- [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n- [The Guile Hacker's Notebook](https://jeko.frama.io/)\n- [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\n- [System Crafters Community](https://systemcrafters.net/)\n\n### Project-Specific\n- [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md) - Design patterns and coding standards\n- [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md) - Common mistakes (frequency-sorted)\n- [GUILE_CONVERSION.md](GUILE_CONVERSION.md) - Bash-to-Guile conversion strategy\n- [POSTINSTALL_DEV.md](POSTINSTALL_DEV.md) - Postinstall development workflow\n\n---\n\n## Changelog\n\n### 2024-11-15: Major Reorganization\n- Split into three focused files:\n  - GUILE_KNOWLEDGE.md (this file): Quick reference and index\n  - GUILE_BEST_PRACTICES.md: Design patterns and principles\n  - GUILE_GOTCHAS.md: Common mistakes with frequency tracking\n- Streamlined content to be a practical quick reference\n- Added navigation guide and file purposes\n\n### 2024-11-14: Enhanced with Community Resources\n- Added best practice themes (moved to GUILE_BEST_PRACTICES.md)\n- Added recommended learning resources\n- Documented common mistakes (moved to GUILE_GOTCHAS.md)\n\n### 2024-11-14: Initial Creation\n- Documented \"read all S-expressions\" mistake\n- Documented SRFI-1 import requirement\n- Added shebang best practices\n- Added pattern matching guide\n- Added file I/O patterns\n- Added testing strategies\n- Added shell integration patterns\n\n---\n\n# Guile/Scheme Best Practices\n\nBest practices and design patterns for writing maintainable Guile code.\n\nBased on:\n- Community resources (Guile Hacker's Notebook, Wingolog, System Crafters)\n- Functional programming principles\n- Real-world experience from this project\n\nFor common mistakes, see [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md).\n\n---\n\n## Table of Contents\n\n1. [Module System](#1-use-the-module-system-properly)\n2. [Separation of Concerns](#2-separate-concerns-repl-script-library)\n3. [Pure Functional Style](#3-prefer-pure-functional-definitions)\n4. [Tail Recursion](#4-use-tail-calls-and-recursion-carefully)\n5. [Incremental Development](#5-write-tests-and-develop-incrementally)\n6. [Code Readability](#6-code-readability-and-naming)\n7. [Abstraction Levels](#7-use-appropriate-abstraction-levels)\n8. [Performance](#8-mind-performance-when-needed)\n9. [Scheme Conventions](#9-follow-scheme-conventions)\n10. [Error Handling](#10-handle-errors-gracefully)\n\n---\n\n## 1. Use the Module System Properly\n\nStructure code into modules with clear interfaces rather than one giant file:\n\n```scheme\n;; lib/my-module.scm\n(define-module (my-module)\n  #:use-module (ice-9 match)\n  #:use-module (srfi srfi-1)\n  #:export (public-function another-function))\n\n(define (public-function arg)\n  ;; Exported, available to other modules\n  ...)\n\n(define (private-helper arg)\n  ;; Not exported, internal only\n  ...)\n```\n\n**When to use modules:**\n- Reusable code across multiple scripts\n- Clear public/private API boundaries\n- Logical grouping of related functions\n\n**When to use standalone scripts:**\n- Single-purpose tools (like our config helpers)\n- Easier distribution (one file)\n- Simpler for end users\n\n---\n\n## 2. Separate Concerns: REPL, Script, Library\n\n- **Library code**: Pure functions, no I/O, easily testable\n- **Script code**: Thin wrapper that handles I/O and calls library\n- **REPL experimentation**: Interactive development, then extract to library\n\n```scheme\n;; Library: pure logic\n(define (calculate-sum items)\n  (fold + 0 items))\n\n;; Script: I/O wrapper\n(define (main args)\n  (let ((numbers (read-numbers-from-file \"input.txt\")))\n    (display (calculate-sum numbers))))\n```\n\n---\n\n## 3. Prefer Pure Functional Definitions\n\nKeep side-effects isolated (I/O, mutation) so bulk of logic is easy to reason about:\n\n```scheme\n;; Good: pure function\n(define (add-service-to-list services new-service)\n  (if (member new-service services)\n      services\n      (cons new-service services)))\n\n;; Avoid: mutation\n(define (add-service-mutating! services new-service)\n  (set! services (cons new-service services)))  ; Don't do this\n```\n\n**Benefits:**\n- Easier to test (no setup/teardown needed)\n- Easier to reason about (no hidden state)\n- Composable (pure functions combine cleanly)\n- Parallelizable (no shared mutable state)\n\n---\n\n## 4. Use Tail Calls and Recursion Carefully\n\nScheme supports proper tail recursion - use it to avoid stack blow-ups:\n\n```scheme\n;; Good: tail recursive (constant stack)\n(define (sum-list lst)\n  (let loop ((items lst) (acc 0))\n    (if (null? items)\n        acc\n        (loop (cdr items) (+ acc (car items))))))\n\n;; Bad: not tail recursive (grows stack)\n(define (sum-list-bad lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (sum-list-bad (cdr lst)))))\n```\n\n**Common tail-recursive patterns:**\n- Named `let` for loops\n- Accumulator parameter for results\n- Always recurse as last operation\n\n**When recursion is appropriate:**\n- Processing lists or trees\n- State machines\n- Iterative algorithms\n\n**When to use built-in functions instead:**\n- `fold`, `map`, `filter` are already optimized\n- More readable than manual recursion\n- Less error-prone\n\n---\n\n## 5. Write Tests and Develop Incrementally\n\n- Write small modules\n- Test via REPL\n- Build up incrementally\n- Keep examples in comments\n\n```scheme\n;; Example usage in comments:\n;; (add-service '(service foo) '(service bar))\n;; => '(service foo service bar)\n\n(define (add-service services new-service)\n  ...)\n```\n\n**Development workflow:**\n\n1. Start in REPL with small test cases\n2. Extract working code to functions\n3. Add docstrings and examples\n4. Create test files for regression testing\n5. Refactor once tests pass\n\n---\n\n## 6. Code Readability and Naming\n\nScheme has minimal syntax - good naming matters even more:\n\n```scheme\n;; Good: descriptive names\n(define (find-operating-system-expr exprs)\n  (find (lambda (expr)\n          (and (pair? expr)\n               (eq? (car expr) 'operating-system)))\n        exprs))\n\n;; Bad: unclear names\n(define (find-os x)\n  (find (lambda (e) (and (pair? e) (eq? (car e) 'operating-system))) x))\n```\n\n**Naming conventions:**\n- Predicates end in `?`: `empty?`, `file-exists?`\n- Mutators end in `!`: `set!`, `delete-file!`\n- Converters use `->`: `string->number`, `list->vector`\n- Use full words, not abbreviations\n- Be consistent with Scheme stdlib naming\n\n**Formatting:**\n- Indent consistently (2 spaces per level)\n- Align closing parens vertically\n- Break long expressions across lines\n- Group related functions together\n\n---\n\n## 7. Use Appropriate Abstraction Levels\n\nHigher-order functions, closures, macros - use when they improve clarity:\n\n```scheme\n;; Good: clear intent with higher-order function\n(filter (lambda (x) (> x 0)) numbers)\n\n;; Overkill: macro where function suffices\n(define-syntax when-positive  ; Don't do this for simple case\n  (syntax-rules ()\n    ((when-positive x body ...)\n     (if (> x 0) (begin body ...)))))\n```\n\n**Abstraction ladder:**\n\n1. **Direct code**: Simplest, most explicit\n2. **Helper functions**: Reduce duplication\n3. **Higher-order functions**: Parameterize behavior\n4. **Macros**: Create new syntax (use sparingly!)\n\n**When to create abstractions:**\n- Pattern appears 3+ times\n- Logic is complex and benefits from naming\n- Future changes will be localized\n\n**When NOT to abstract:**\n- One-off code\n- Abstraction obscures intent\n- Too early (wait for real duplication)\n\n---\n\n## 8. Mind Performance When Needed\n\n- Use tail recursion to avoid stack growth\n- Avoid quadratic operations (repeated `append`)\n- Consider compilation for frequently-run code\n- Profile before optimizing\n\n```scheme\n;; Slow: O(nÂ²) with repeated append\n(let loop ((items input) (result '()))\n  (if (null? items)\n      result\n      (loop (cdr items) (append result (list (car items))))))\n\n;; Fast: O(n) with cons + reverse\n(reverse\n  (let loop ((items input) (result '()))\n    (if (null? items)\n        result\n        (loop (cdr items) (cons (car items) result)))))\n```\n\n**Common performance pitfalls:**\n- `append` on right side of list (O(n) per call)\n- Deep recursion without tail calls (stack overflow)\n- String concatenation in loops (use `string-append` with list, then join)\n- Repeated `length` calls (cache it if needed)\n\n**Optimization strategy:**\n\n1. Write correct code first\n2. Measure if performance matters\n3. Identify bottlenecks (profiling)\n4. Apply targeted optimizations\n5. Verify correctness still holds\n\n---\n\n## 9. Follow Scheme Conventions\n\nEven with Guile-specific features, stick to Scheme idioms:\n\n**Lexical scope:**\n- Use `let`, `let*`, `letrec` appropriately\n- `let`: bindings don't see each other\n- `let*`: sequential bindings (can reference earlier ones)\n- `letrec`: recursive bindings\n\n**Immutability:**\n- Default to immutable data structures\n- Return new values instead of mutating\n- Use `!` suffix only when truly necessary\n\n**Proper tail calls:**\n- Scheme guarantees tail call optimization\n- Rely on it for iteration\n- No need for explicit loops (unless clearer)\n\n**Closures:**\n- Capture environment for encapsulation\n- Create stateful objects functionally\n- Return functions from functions\n\n---\n\n## 10. Handle Errors Gracefully\n\nProvide helpful error messages with context:\n\n```scheme\n;; Bad: generic error\n(if (not (file-exists? config-file))\n    (error \"File not found\"))\n\n;; Good: specific context\n(if (not (file-exists? config-file))\n    (error (format #f \"Config file not found: ~a\\nExpected at: ~a\"\n                   config-file\n                   (dirname config-file))))\n```\n\n**Error handling strategies:**\n\n**Guard against invalid input:**\n```scheme\n(define (divide a b)\n  (if (zero? b)\n      (error \"Cannot divide by zero\")\n      (/ a b)))\n```\n\n**Validate early:**\n```scheme\n(define (process-config filepath)\n  ;; Validate upfront\n  (unless (file-exists? filepath)\n    (error (format #f \"Config not found: ~a\" filepath)))\n  (unless (access? filepath R_OK)\n    (error (format #f \"Config not readable: ~a\" filepath)))\n\n  ;; Now process\n  ...)\n```\n\n**Provide recovery options:**\n```scheme\n(define (safe-read-config filepath fallback)\n  (if (file-exists? filepath)\n      (call-with-input-file filepath read)\n      fallback))\n```\n\n---\n\n## Resources\n\n### Recommended Learning Resources\n\n#### 1. [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n**The official manual** for Guile, covering how to use it interactively, scripting, modules, debugging, etc.\n\n**Why useful:** Gives you the \"what\" of Guile and how to use the language in practice (not just theory).\n\n**Tip:** Use this as your baseline reference. Whenever you're unsure how to structure a module, script, or use a particular part of the API â€” go here.\n\n#### 2. [The Guile Hacker's Notebook](https://jeko.frama.io/)\nA resource dedicated specifically to Guile: covers concrete programming situations and brings best-practice thinking (TDD, clean code, architecture) into Scheme/Guile.\n\n**Why useful:** Covers how to write maintainable code in Guile, not just syntax.\n\n**Tip:** As you advance from basic syntax into \"how to write maintainable code in Guile\", this is very helpful.\n\n#### 3. [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\nBlog posts and talks by a Guile maintainer. For example: [\"Lessons Learned from Guile, the Ancient & Spry\"](https://wingolog.org/archives/2016/01/11/lessons-learned-from-guile-the-ancient-and-spry)\n\n**Why useful:** Meta-level thinking about how Guile is built and evolves - informs design decisions and best practices.\n\n**Tip:** Use this for understanding \"why\" Guile works the way it does, which helps you make better architecture/style choices.\n\n#### 4. [System Crafters Community Discussions](https://systemcrafters.net/)\nCommunity discussions like \"Is there a good learning material on Guile Scheme?\"\n\n**Why useful:** Honest user reflections - what they found difficult, what worked, common gotchas.\n\n**Tip:** Browse these to see common patterns and pitfalls (especially with modules, REPL, embedding).\n\n### Official Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Quick References\n- Pattern matching: [ice-9 match](https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html)\n- File I/O: [Ports and File Descriptors](https://www.gnu.org/software/guile/manual/html_node/File-Ports.html)\n- Pretty-printing: [ice-9 pretty-print](https://www.gnu.org/software/guile/manual/html_node/Pretty_002dPrinting.html)\n- Tail calls: [Expressions](https://www.gnu.org/software/guile/manual/html_node/Expressions.html)\n- Modules: [Modules](https://www.gnu.org/software/guile/manual/html_node/Modules.html)\n\n### Performance and Optimization\n- [David Thompson: Optimizing Guile](https://dthompson.us/posts/optimize-guile.html)\n- Guile compilation, bytecode, and performance considerations\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted best practices from GUILE_KNOWLEDGE.md\n- Organized into 10 thematic sections\n- Added practical examples for each principle\n- Included learning resources and references\n\n---\n\n# Guile/Scheme Gotchas and Common Mistakes\n\nThis document tracks mistakes we've actually made during development, sorted by frequency.\n\n**Format**: Each gotcha includes:\n- **Count**: Number of times we've hit this issue (kept up-to-date)\n- **The Mistake**: What we did wrong\n- **Why It Failed**: Technical explanation\n- **The Fix**: Correct approach\n- **When to Watch For**: Situations where this mistake is likely\n\n---\n\n## Gotcha Leaderboard (Sorted by Frequency)\n\n### [Count: 3] Missing SRFI-1 Import\n\n**The Mistake:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match))\n\n;; Later in code:\n(let ((filtered (filter-map some-fn items)))  ; ERROR!\n  ...)\n```\n\n**Why It Failed:**\n```\nERROR: Unbound variable: filter-map\n```\n\nList processing functions like `filter-map`, `fold`, `take`, `take-right`, etc. are not part of core Guile - they come from SRFI-1.\n\n**The Fix:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (srfi srfi-1))  ; REQUIRED for list functions\n```\n\n**When to Watch For:**\n- Using any list function beyond basic `car`, `cdr`, `cons`, `append`\n- Processing collections with `filter-map`, `fold`, `partition`\n- Taking slices with `take`, `drop`, `take-right`, `drop-right`\n\n**Frequency Notes:**\n- 2024-11-14: Initial occurrence (guile-config-helper.scm)\n- 2024-11-14: bootstrap-postinstall.scm (take/take-right)\n- 2024-11-15: Future occurrence tracking starts here\n\n---\n\n### [Count: 2] Wrong Shebang for Piped Execution\n\n**The Mistake:**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\nWhen piped: `curl ... | guile`\n\n**Why It Failed:**\n```\n;;; In procedure primitive-load:\n;;; No such file or directory: \"/home/durant/-\"\n```\n\nThe `-s` flag tells Guile to expect a script filename argument. When piped, leftover `-` from arguments gets interpreted as a file path.\n\n**The Fix:**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n**When to Watch For:**\n- Creating scripts meant to be piped via curl\n- Scripts that should read from stdin\n- Bootstrap/installer scripts\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm initial shebang\n- 2024-11-15: Fixed by removing -s flag\n\n---\n\n### [Count: 2] Using macOS Commands on Guix\n\n**The Mistake:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"shasum -a 256 ~s\" filepath)))\n         ...))\n```\n\n**Why It Failed:**\n```\n/gnu/store/.../bash: line 1: shasum: command not found\n```\n\n`shasum` is a BSD/macOS tool. Guix systems use GNU coreutils which provides `sha256sum`.\n\n**The Fix:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"sha256sum ~s\" filepath)))\n         ...))\n```\n\n**When to Watch For:**\n- Porting scripts from macOS development to Guix deployment\n- Using BSD-specific commands: `shasum`, `md5`, `gstat`, etc.\n- Always use GNU coreutils equivalents: `sha256sum`, `md5sum`, `stat`\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm checksum function\n- 2024-11-15: Will likely happen again when porting more scripts\n\n---\n\n### [Count: 1] Reading Only First S-expression\n\n**The Mistake:**\n```scheme\n(define (read-config filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (read port))))  ; ONLY READS FIRST FORM!\n```\n\n**Why It Failed:**\nGuix config files have multiple top-level S-expressions:\n```scheme\n(use-modules (gnu))  ; First form\n(use-modules (gnu services networking))  ; Second form\n(operating-system ...)  ; Third form\n```\n\nOnly got `(use-modules (gnu))`, missing the rest!\n\n**The Fix:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**When to Watch For:**\n- Reading Guix config files (always have multiple use-modules + operating-system)\n- Processing Scheme files with multiple top-level definitions\n- Any file that's more than a single S-expression\n\n**Frequency Notes:**\n- 2024-11-14: guile-config-helper.scm initial implementation\n\n---\n\n### [Count: 1] Wrong Invocation for Piped Scripts\n\n**The Mistake:**\n```bash\ncurl ... | guile --no-auto-compile -s -\n```\n\n**Why It Failed:**\nThe `-s -` combination causes Guile to look for a script file named `-`, leading to path resolution errors.\n\n**The Fix:**\n```bash\ncurl ... | guile\n```\n\nWith the correct shebang (backslash continuation, no `-s`), Guile reads from stdin automatically.\n\n**When to Watch For:**\n- One-liner bootstrap commands\n- Documentation examples for piped execution\n- CI/CD scripts that download and run Guile code\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm documentation\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted gotchas from GUILE_KNOWLEDGE.md\n- Established frequency tracking system\n- Sorted by count (highest first)\n- Added 5 initial gotchas with counts\n\n### Frequency Tracking Protocol\n\nWhen you encounter a gotcha:\n\n1. **If it's already listed**: Increment the count, add date note\n2. **If it's new**: Add it with `[Count: 1]`, insert in sorted position\n3. **Periodically re-sort**: Keep highest-frequency gotchas at top\n4. **Update notes**: Add specific occurrence details to help identify patterns\n\nThis ensures the most common mistakes are always visible first!\n\n---\n\n# Guile Conversion Plan\n\n## Overview\n\nWe're systematically converting all shell scripts that run on Guix systems to Guile Scheme. This provides:\n\n- **Proper S-expression handling** for config.scm manipulation\n- **Type safety** and better error handling\n- **Consistency** with Guix's native language\n- **Maintainability** through structured code\n- **Future-proofing** for advanced Guix features\n\n## Conversion Strategy\n\n### Phase 1: Library Infrastructure (COMPLETED)\n- âœ… Created `lib/guile-config-helper.scm` for S-expression manipulation\n- âœ… Set up Guile testing in Docker\n- âœ… Created test framework in `lib/tests/`\n- âœ… Verified Guile integration with existing Go/shell tests\n\n### Phase 2: Postinstall Scripts (IN PROGRESS)\nConvert postinstall customization scripts to use Guile helper:\n\n1. Update `framework-dual/postinstall/customize` to use Guile helper\n2. Create similar for other platforms\n3. Test GNOME, NetworkManager, SSH configurations\n\n### Phase 3: Critical Installation Scripts (PLANNED)\nConvert lib/*.sh scripts to Guile:\n\nPriority order (by complexity and criticality):\n\n1. **lib/postinstall.sh** (744B) - Simplest, good starting point\n   - Channel generation utilities\n   - Used by customize scripts\n\n2. **lib/clean-install.sh** (3.0K) - Medium complexity\n   - Clean installation wrapper\n   - Calls into Go installer\n\n3. **lib/verify-guix-install.sh** (8.2K) - Complex verification\n   - Post-install verification\n   - System checks\n\n4. **lib/bootstrap-installer.sh** (7.6K) - Bootstrap logic\n   - Downloads and verifies repo\n   - Builds Go installer\n\n5. **lib/recovery-complete-install.sh** (13K) - Most complex\n   - Recovery scenarios\n   - Multiple installation paths\n\n6. **lib/channel-utils.sh** (6.8K) - Channel management\n   - Mirror selection\n   - Channel configuration\n\n### Phase 4: Integration and Testing\n- Update all platform READMEs\n- Create comprehensive Guile test suite\n- Docker testing for all conversions\n- Update documentation\n\n## Conversion Guidelines\n\n### Shebang for Guile Scripts on Guix\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n### Module Structure\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (ice-9 rdelim)\n             (srfi srfi-1)\n             (srfi srfi-26))  ; cut/cute for partial application\n```\n\n### Common Patterns\n\n#### Bash â†’ Guile\n\n**Command execution:**\n```bash\n# Bash\noutput=$(command arg1 arg2)\nif [ $? -eq 0 ]; then\n    echo \"Success\"\nfi\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 popen) (ice-9 rdelim))\n\n(let* ((port (open-input-pipe \"command arg1 arg2\"))\n       (output (read-string port))\n       (status (close-pipe port)))\n  (if (zero? status)\n      (display \"Success\\n\")))\n```\n\n**File operations:**\n```bash\n# Bash\nif [ -f \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n```\n\n```scheme\n;; Guile\n(when (file-exists? file)\n  (let ((content (call-with-input-file file read-string)))\n    ...))\n```\n\n**Argument parsing:**\n```bash\n# Bash\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --flag) FLAG=true; shift ;;\n        *) ARG=$1; shift ;;\n    esac\ndone\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 getopt-long))\n\n(define option-spec\n  '((flag (single-char #\\f) (value #f))\n    (arg (single-char #\\a) (value #t))))\n\n(let ((options (getopt-long (command-line) option-spec)))\n  (define flag (option-ref options 'flag #f))\n  (define arg (option-ref options 'arg #f))\n  ...)\n```\n\n## Testing Requirements\n\nEach converted script must have:\n\n1. **Unit tests** in `lib/tests/test-<script-name>.scm`\n2. **Integration tests** verifying behavior matches bash version\n3. **Docker tests** ensuring Guile dependencies are available\n4. **Documentation** explaining any behavior changes\n\n## Status Tracking\n\n| Script | Lines | Status | Tests | Notes |\n|--------|-------|--------|-------|-------|\n| guile-config-helper.scm | 169 | âœ… Done | âœ… Passing | S-expression manipulation |\n| postinstall.sh | 31 | ðŸ”„ Next | â¸ï¸ Pending | Channel utilities |\n| clean-install.sh | 134 | â¸ï¸ Planned | â¸ï¸ Pending | Installation wrapper |\n| verify-guix-install.sh | 305 | â¸ï¸ Planned | â¸ï¸ Pending | Verification checks |\n| bootstrap-installer.sh | 267 | â¸ï¸ Planned | â¸ï¸ Pending | Bootstrap logic |\n| recovery-complete-install.sh | 458 | â¸ï¸ Planned | â¸ï¸ Pending | Recovery flows |\n| channel-utils.sh | 235 | â¸ï¸ Planned | â¸ï¸ Pending | Channel/mirror selection |\n\n## Migration Path\n\nFor each script:\n\n1. **Analyze** - Understand current bash implementation\n2. **Design** - Plan Guile equivalent with better structure\n3. **Implement** - Write .scm version alongside .sh\n4. **Test** - Comprehensive testing in Docker + real Guix\n5. **Document** - Update all references and docs\n6. **Deploy** - Switch references from .sh to .scm\n7. **Deprecate** - Mark .sh as deprecated\n8. **Remove** - Delete .sh after stable period\n\n## Notes\n\n- **Coexistence**: .sh and .scm versions will coexist during transition\n- **Testing**: Both versions tested until .scm proven stable\n- **Rollback**: Keep .sh versions until all platforms verified\n- **Knowledge Base**: See [GUILE_KNOWLEDGE.md](GUILE_KNOWLEDGE.md) for lessons learned and best practices\n- **Read First**: Review GUILE_KNOWLEDGE.md before starting any Guile development work\n\n\n---\n\nORIGINAL SCRIPT PATH: postinstall/recipes/add-development.sh\n\nORIGINAL SCRIPT CONTENT:\n\n#!/usr/bin/env bash\n# Shared recipe: Install common development tools\n# Can be called from any platform's customize tool\n\nset -euo pipefail\n\nCONFIG_FILE=\"${CONFIG_FILE:-/etc/config.scm}\"\n\n# Colors\ninfo() { printf \"  %s\\n\" \"$*\"; }\nsuccess() { printf \"\\n\\033[1;32m[âœ“]\\033[0m %s\\n\" \"$*\"; }\n\nadd_development() {\n  echo \"\"\n  echo \"=== Installing Development Tools ===\"\n  echo \"\"\n\n  info \"Adding development packages to config.scm...\"\n\n  # List of common development tools\n  local dev_packages=(\n    \"git\"\n    \"vim\"\n    \"emacs\"\n    \"make\"\n    \"gcc-toolchain\"\n    \"python\"\n    \"node\"\n    \"go\"\n    \"curl\"\n    \"wget\"\n    \"ripgrep\"\n    \"fd\"\n    \"tmux\"\n    \"htop\"\n  )\n\n  # Check if packages section exists\n  if grep -q \"(packages %base-packages)\" \"$CONFIG_FILE\"; then\n    # Minimal config - need to create packages list\n    local package_list=\"\"\n    for pkg in \"${dev_packages[@]}\"; do\n      package_list+=\"                (specification->package \\\"$pkg\\\")\\n\"\n    done\n\n    sed -i \"s|(packages %base-packages)|(packages\\n  (append\\n   (list\\n${package_list}         )\\n   %base-packages))|\" \"$CONFIG_FILE\"\n  else\n    # Already has packages, add development tools\n    for pkg in \"${dev_packages[@]}\"; do\n      if ! grep -q \"\\\"$pkg\\\"\" \"$CONFIG_FILE\"; then\n        # Find the packages section and add the package\n        sed -i \"/specification->package/a\\                (specification->package \\\"$pkg\\\")\" \"$CONFIG_FILE\"\n      fi\n    done\n  fi\n\n  success \"Development tools added to configuration!\"\n  echo \"\"\n  info \"Packages added:\"\n  for pkg in \"${dev_packages[@]}\"; do\n    info \"  - $pkg\"\n  done\n  echo \"\"\n  info \"Apply changes with: sudo guix system reconfigure /etc/config.scm\"\n}\n\n# Run if called directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n  add_development\nfi\n\n\n---\n\nCONVERSION REQUIREMENTS:\n\n1. Use proper Guile shebang: #!/run/current-system/profile/bin/guile --no-auto-compile -s\n2. Include all necessary use-modules (ice-9 popen, ice-9 rdelim, ice-9 format, srfi srfi-1)\n3. Convert all bash functions to Guile procedures\n4. Use Guile idioms: call-with-input-file, open-input-pipe, etc.\n5. Maintain all functionality from the original script\n6. Add comments explaining complex conversions\n7. Follow naming conventions: predicates end in ?, mutators end in !\n8. Use tail recursion where appropriate\n9. Use GNU coreutils commands (sha256sum not shasum, etc.)\n\nOUTPUT FORMAT:\n\nProvide ONLY the complete converted Guile script. No explanations, no markdown formatting, just the raw .scm file content starting with the shebang.\n"
      }
    ]
  }
}

{
  "custom_id": "convert-postinstall-recipes-add-doom-emacs",
  "params": {
    "model": "claude-sonnet-4-5",
    "max_tokens": 8192,
    "messages": [
      {
        "role": "user",
        "content": "Convert this bash script to Guile Scheme following the documentation provided.\n\nREFERENCE DOCUMENTATION:\n\n# GUILE KNOWLEDGE BASE\n\n# Guile Development Knowledge Base\n\n**Purpose**: Central index for Guile Scheme development knowledge in this project.\n\n**Read this before**: Starting any new Guile script or modifying existing .scm files.\n\n---\n\n## Quick Navigation\n\n### ðŸ“š [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md)\nBest practices and design patterns for writing maintainable Guile code.\n\n**Topics:**\n- Module system usage\n- Separation of concerns (REPL/Script/Library)\n- Pure functional style\n- Tail recursion patterns\n- Incremental development\n- Code readability and naming\n- Abstraction levels\n- Performance optimization\n- Scheme conventions\n- Error handling\n\n**Read this**: When designing new functions or refactoring existing code.\n\n---\n\n### âš ï¸  [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md)\nCommon mistakes sorted by frequency (most common first).\n\n**Current top gotchas:**\n1. Missing SRFI-1 import (Count: 3)\n2. Wrong shebang for piped execution (Count: 2)\n3. Using macOS commands on Guix (Count: 2)\n4. Reading only first S-expression (Count: 1)\n5. Wrong invocation for piped scripts (Count: 1)\n\n**Read this**: When you encounter an error, or before writing similar code patterns.\n\n---\n\n## Guile Quick Reference (This Project)\n\n### Standard Shebang for Standalone Scripts\n\n**For regular scripts (executed directly):**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n**For scripts meant to be piped (bootstrap scripts):**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n### Essential Imports\n\n**Minimum for most scripts:**\n```scheme\n(use-modules (ice-9 popen)       ; Command execution\n             (ice-9 rdelim)      ; Line reading\n             (ice-9 format)      ; String formatting\n             (srfi srfi-1))      ; List processing\n```\n\n**For S-expression manipulation:**\n```scheme\n(use-modules (ice-9 pretty-print) ; Pretty-print S-exprs\n             (ice-9 match)        ; Pattern matching\n             (srfi srfi-1))       ; List functions\n```\n\n### Common Patterns\n\n**Reading all S-expressions from a file:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**Executing shell command and capturing output:**\n```scheme\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (values output status)))\n```\n\n**Pattern matching on S-expressions:**\n```scheme\n(use-modules (ice-9 match))\n\n(match expr\n  (('operating-system fields ...)\n   ;; Handle operating-system form\n   ...)\n  (('use-modules modules ...)\n   ;; Handle use-modules form\n   ...)\n  (else\n   ;; Default case\n   ...))\n```\n\n---\n\n## Testing Strategy\n\n### REPL-Driven Development\n\n1. Start Guile REPL: `guile`\n2. Load your module: `(load \"lib/my-script.scm\")`\n3. Test functions interactively\n4. Fix issues and reload\n5. Once working, extract to clean script\n\n### Integration Testing\n\n**For config manipulation:**\n```bash\n# Test with sample config file\nframework-dual/postinstall/tests/run-guile-tests.sh\n```\n\n**For bootstrap scripts:**\n```bash\n# Test in Docker environment\n./test-docker.sh test\n```\n\n---\n\n## File I/O Reference\n\n### Reading Files\n\n```scheme\n;; Read entire file as string\n(call-with-input-file \"path/to/file\" read-string)\n\n;; Read all S-expressions\n(call-with-input-file \"config.scm\"\n  (lambda (port)\n    (let loop ((exprs '()))\n      (let ((expr (read port)))\n        (if (eof-object? expr)\n            (reverse exprs)\n            (loop (cons expr exprs)))))))\n\n;; Read line by line\n(call-with-input-file \"path/to/file\"\n  (lambda (port)\n    (let loop ((lines '()))\n      (let ((line (read-line port)))\n        (if (eof-object? line)\n            (reverse lines)\n            (loop (cons line lines)))))))\n```\n\n### Writing Files\n\n```scheme\n;; Write string to file\n(call-with-output-file \"path/to/file\"\n  (lambda (port)\n    (display \"content\" port)))\n\n;; Pretty-print S-expression to file\n(call-with-output-file \"config.scm\"\n  (lambda (port)\n    (pretty-print expr port)))\n```\n\n---\n\n## Shell Integration\n\n### Running Commands\n\n```scheme\n;; Simple command execution (return status)\n(system \"ls -la\")  ; Returns exit code\n\n;; Execute with proper error handling\n(define (system* cmd)\n  (let ((status (system cmd)))\n    (zero? status)))\n\n;; Capture output\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (if (zero? status)\n        output\n        #f)))\n```\n\n### Platform-Specific Commands\n\n**ALWAYS use GNU coreutils on Guix:**\n- âœ… `sha256sum` (NOT `shasum`)\n- âœ… `md5sum` (NOT `md5`)\n- âœ… `stat` (NOT `gstat`)\n\nSee [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md#count-2-using-macos-commands-on-guix) for details.\n\n---\n\n## When to Use Guile vs Bash\n\n### Use Guile when:\n- Manipulating S-expressions (config.scm files)\n- Complex data transformations\n- Need proper error handling\n- Cross-platform script requirements\n\n### Use Bash when:\n- Simple file operations\n- Gluing together CLI tools\n- Quick one-liners\n- Temporary helper scripts\n\n### Use Guile from Bash:\n```bash\n# Call Guile helper from bash\nguile_add_service() {\n  local module=\"$1\"\n  local service=\"$2\"\n\n  guile --no-auto-compile -s lib/guile-config-helper.scm \\\n    add-service /etc/config.scm \"$module\" \"$service\"\n}\n```\n\n---\n\n## Resources\n\n### Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Learning Resources\n- [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n- [The Guile Hacker's Notebook](https://jeko.frama.io/)\n- [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\n- [System Crafters Community](https://systemcrafters.net/)\n\n### Project-Specific\n- [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md) - Design patterns and coding standards\n- [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md) - Common mistakes (frequency-sorted)\n- [GUILE_CONVERSION.md](GUILE_CONVERSION.md) - Bash-to-Guile conversion strategy\n- [POSTINSTALL_DEV.md](POSTINSTALL_DEV.md) - Postinstall development workflow\n\n---\n\n## Changelog\n\n### 2024-11-15: Major Reorganization\n- Split into three focused files:\n  - GUILE_KNOWLEDGE.md (this file): Quick reference and index\n  - GUILE_BEST_PRACTICES.md: Design patterns and principles\n  - GUILE_GOTCHAS.md: Common mistakes with frequency tracking\n- Streamlined content to be a practical quick reference\n- Added navigation guide and file purposes\n\n### 2024-11-14: Enhanced with Community Resources\n- Added best practice themes (moved to GUILE_BEST_PRACTICES.md)\n- Added recommended learning resources\n- Documented common mistakes (moved to GUILE_GOTCHAS.md)\n\n### 2024-11-14: Initial Creation\n- Documented \"read all S-expressions\" mistake\n- Documented SRFI-1 import requirement\n- Added shebang best practices\n- Added pattern matching guide\n- Added file I/O patterns\n- Added testing strategies\n- Added shell integration patterns\n\n---\n\n# Guile/Scheme Best Practices\n\nBest practices and design patterns for writing maintainable Guile code.\n\nBased on:\n- Community resources (Guile Hacker's Notebook, Wingolog, System Crafters)\n- Functional programming principles\n- Real-world experience from this project\n\nFor common mistakes, see [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md).\n\n---\n\n## Table of Contents\n\n1. [Module System](#1-use-the-module-system-properly)\n2. [Separation of Concerns](#2-separate-concerns-repl-script-library)\n3. [Pure Functional Style](#3-prefer-pure-functional-definitions)\n4. [Tail Recursion](#4-use-tail-calls-and-recursion-carefully)\n5. [Incremental Development](#5-write-tests-and-develop-incrementally)\n6. [Code Readability](#6-code-readability-and-naming)\n7. [Abstraction Levels](#7-use-appropriate-abstraction-levels)\n8. [Performance](#8-mind-performance-when-needed)\n9. [Scheme Conventions](#9-follow-scheme-conventions)\n10. [Error Handling](#10-handle-errors-gracefully)\n\n---\n\n## 1. Use the Module System Properly\n\nStructure code into modules with clear interfaces rather than one giant file:\n\n```scheme\n;; lib/my-module.scm\n(define-module (my-module)\n  #:use-module (ice-9 match)\n  #:use-module (srfi srfi-1)\n  #:export (public-function another-function))\n\n(define (public-function arg)\n  ;; Exported, available to other modules\n  ...)\n\n(define (private-helper arg)\n  ;; Not exported, internal only\n  ...)\n```\n\n**When to use modules:**\n- Reusable code across multiple scripts\n- Clear public/private API boundaries\n- Logical grouping of related functions\n\n**When to use standalone scripts:**\n- Single-purpose tools (like our config helpers)\n- Easier distribution (one file)\n- Simpler for end users\n\n---\n\n## 2. Separate Concerns: REPL, Script, Library\n\n- **Library code**: Pure functions, no I/O, easily testable\n- **Script code**: Thin wrapper that handles I/O and calls library\n- **REPL experimentation**: Interactive development, then extract to library\n\n```scheme\n;; Library: pure logic\n(define (calculate-sum items)\n  (fold + 0 items))\n\n;; Script: I/O wrapper\n(define (main args)\n  (let ((numbers (read-numbers-from-file \"input.txt\")))\n    (display (calculate-sum numbers))))\n```\n\n---\n\n## 3. Prefer Pure Functional Definitions\n\nKeep side-effects isolated (I/O, mutation) so bulk of logic is easy to reason about:\n\n```scheme\n;; Good: pure function\n(define (add-service-to-list services new-service)\n  (if (member new-service services)\n      services\n      (cons new-service services)))\n\n;; Avoid: mutation\n(define (add-service-mutating! services new-service)\n  (set! services (cons new-service services)))  ; Don't do this\n```\n\n**Benefits:**\n- Easier to test (no setup/teardown needed)\n- Easier to reason about (no hidden state)\n- Composable (pure functions combine cleanly)\n- Parallelizable (no shared mutable state)\n\n---\n\n## 4. Use Tail Calls and Recursion Carefully\n\nScheme supports proper tail recursion - use it to avoid stack blow-ups:\n\n```scheme\n;; Good: tail recursive (constant stack)\n(define (sum-list lst)\n  (let loop ((items lst) (acc 0))\n    (if (null? items)\n        acc\n        (loop (cdr items) (+ acc (car items))))))\n\n;; Bad: not tail recursive (grows stack)\n(define (sum-list-bad lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (sum-list-bad (cdr lst)))))\n```\n\n**Common tail-recursive patterns:**\n- Named `let` for loops\n- Accumulator parameter for results\n- Always recurse as last operation\n\n**When recursion is appropriate:**\n- Processing lists or trees\n- State machines\n- Iterative algorithms\n\n**When to use built-in functions instead:**\n- `fold`, `map`, `filter` are already optimized\n- More readable than manual recursion\n- Less error-prone\n\n---\n\n## 5. Write Tests and Develop Incrementally\n\n- Write small modules\n- Test via REPL\n- Build up incrementally\n- Keep examples in comments\n\n```scheme\n;; Example usage in comments:\n;; (add-service '(service foo) '(service bar))\n;; => '(service foo service bar)\n\n(define (add-service services new-service)\n  ...)\n```\n\n**Development workflow:**\n\n1. Start in REPL with small test cases\n2. Extract working code to functions\n3. Add docstrings and examples\n4. Create test files for regression testing\n5. Refactor once tests pass\n\n---\n\n## 6. Code Readability and Naming\n\nScheme has minimal syntax - good naming matters even more:\n\n```scheme\n;; Good: descriptive names\n(define (find-operating-system-expr exprs)\n  (find (lambda (expr)\n          (and (pair? expr)\n               (eq? (car expr) 'operating-system)))\n        exprs))\n\n;; Bad: unclear names\n(define (find-os x)\n  (find (lambda (e) (and (pair? e) (eq? (car e) 'operating-system))) x))\n```\n\n**Naming conventions:**\n- Predicates end in `?`: `empty?`, `file-exists?`\n- Mutators end in `!`: `set!`, `delete-file!`\n- Converters use `->`: `string->number`, `list->vector`\n- Use full words, not abbreviations\n- Be consistent with Scheme stdlib naming\n\n**Formatting:**\n- Indent consistently (2 spaces per level)\n- Align closing parens vertically\n- Break long expressions across lines\n- Group related functions together\n\n---\n\n## 7. Use Appropriate Abstraction Levels\n\nHigher-order functions, closures, macros - use when they improve clarity:\n\n```scheme\n;; Good: clear intent with higher-order function\n(filter (lambda (x) (> x 0)) numbers)\n\n;; Overkill: macro where function suffices\n(define-syntax when-positive  ; Don't do this for simple case\n  (syntax-rules ()\n    ((when-positive x body ...)\n     (if (> x 0) (begin body ...)))))\n```\n\n**Abstraction ladder:**\n\n1. **Direct code**: Simplest, most explicit\n2. **Helper functions**: Reduce duplication\n3. **Higher-order functions**: Parameterize behavior\n4. **Macros**: Create new syntax (use sparingly!)\n\n**When to create abstractions:**\n- Pattern appears 3+ times\n- Logic is complex and benefits from naming\n- Future changes will be localized\n\n**When NOT to abstract:**\n- One-off code\n- Abstraction obscures intent\n- Too early (wait for real duplication)\n\n---\n\n## 8. Mind Performance When Needed\n\n- Use tail recursion to avoid stack growth\n- Avoid quadratic operations (repeated `append`)\n- Consider compilation for frequently-run code\n- Profile before optimizing\n\n```scheme\n;; Slow: O(nÂ²) with repeated append\n(let loop ((items input) (result '()))\n  (if (null? items)\n      result\n      (loop (cdr items) (append result (list (car items))))))\n\n;; Fast: O(n) with cons + reverse\n(reverse\n  (let loop ((items input) (result '()))\n    (if (null? items)\n        result\n        (loop (cdr items) (cons (car items) result)))))\n```\n\n**Common performance pitfalls:**\n- `append` on right side of list (O(n) per call)\n- Deep recursion without tail calls (stack overflow)\n- String concatenation in loops (use `string-append` with list, then join)\n- Repeated `length` calls (cache it if needed)\n\n**Optimization strategy:**\n\n1. Write correct code first\n2. Measure if performance matters\n3. Identify bottlenecks (profiling)\n4. Apply targeted optimizations\n5. Verify correctness still holds\n\n---\n\n## 9. Follow Scheme Conventions\n\nEven with Guile-specific features, stick to Scheme idioms:\n\n**Lexical scope:**\n- Use `let`, `let*`, `letrec` appropriately\n- `let`: bindings don't see each other\n- `let*`: sequential bindings (can reference earlier ones)\n- `letrec`: recursive bindings\n\n**Immutability:**\n- Default to immutable data structures\n- Return new values instead of mutating\n- Use `!` suffix only when truly necessary\n\n**Proper tail calls:**\n- Scheme guarantees tail call optimization\n- Rely on it for iteration\n- No need for explicit loops (unless clearer)\n\n**Closures:**\n- Capture environment for encapsulation\n- Create stateful objects functionally\n- Return functions from functions\n\n---\n\n## 10. Handle Errors Gracefully\n\nProvide helpful error messages with context:\n\n```scheme\n;; Bad: generic error\n(if (not (file-exists? config-file))\n    (error \"File not found\"))\n\n;; Good: specific context\n(if (not (file-exists? config-file))\n    (error (format #f \"Config file not found: ~a\\nExpected at: ~a\"\n                   config-file\n                   (dirname config-file))))\n```\n\n**Error handling strategies:**\n\n**Guard against invalid input:**\n```scheme\n(define (divide a b)\n  (if (zero? b)\n      (error \"Cannot divide by zero\")\n      (/ a b)))\n```\n\n**Validate early:**\n```scheme\n(define (process-config filepath)\n  ;; Validate upfront\n  (unless (file-exists? filepath)\n    (error (format #f \"Config not found: ~a\" filepath)))\n  (unless (access? filepath R_OK)\n    (error (format #f \"Config not readable: ~a\" filepath)))\n\n  ;; Now process\n  ...)\n```\n\n**Provide recovery options:**\n```scheme\n(define (safe-read-config filepath fallback)\n  (if (file-exists? filepath)\n      (call-with-input-file filepath read)\n      fallback))\n```\n\n---\n\n## Resources\n\n### Recommended Learning Resources\n\n#### 1. [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n**The official manual** for Guile, covering how to use it interactively, scripting, modules, debugging, etc.\n\n**Why useful:** Gives you the \"what\" of Guile and how to use the language in practice (not just theory).\n\n**Tip:** Use this as your baseline reference. Whenever you're unsure how to structure a module, script, or use a particular part of the API â€” go here.\n\n#### 2. [The Guile Hacker's Notebook](https://jeko.frama.io/)\nA resource dedicated specifically to Guile: covers concrete programming situations and brings best-practice thinking (TDD, clean code, architecture) into Scheme/Guile.\n\n**Why useful:** Covers how to write maintainable code in Guile, not just syntax.\n\n**Tip:** As you advance from basic syntax into \"how to write maintainable code in Guile\", this is very helpful.\n\n#### 3. [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\nBlog posts and talks by a Guile maintainer. For example: [\"Lessons Learned from Guile, the Ancient & Spry\"](https://wingolog.org/archives/2016/01/11/lessons-learned-from-guile-the-ancient-and-spry)\n\n**Why useful:** Meta-level thinking about how Guile is built and evolves - informs design decisions and best practices.\n\n**Tip:** Use this for understanding \"why\" Guile works the way it does, which helps you make better architecture/style choices.\n\n#### 4. [System Crafters Community Discussions](https://systemcrafters.net/)\nCommunity discussions like \"Is there a good learning material on Guile Scheme?\"\n\n**Why useful:** Honest user reflections - what they found difficult, what worked, common gotchas.\n\n**Tip:** Browse these to see common patterns and pitfalls (especially with modules, REPL, embedding).\n\n### Official Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Quick References\n- Pattern matching: [ice-9 match](https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html)\n- File I/O: [Ports and File Descriptors](https://www.gnu.org/software/guile/manual/html_node/File-Ports.html)\n- Pretty-printing: [ice-9 pretty-print](https://www.gnu.org/software/guile/manual/html_node/Pretty_002dPrinting.html)\n- Tail calls: [Expressions](https://www.gnu.org/software/guile/manual/html_node/Expressions.html)\n- Modules: [Modules](https://www.gnu.org/software/guile/manual/html_node/Modules.html)\n\n### Performance and Optimization\n- [David Thompson: Optimizing Guile](https://dthompson.us/posts/optimize-guile.html)\n- Guile compilation, bytecode, and performance considerations\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted best practices from GUILE_KNOWLEDGE.md\n- Organized into 10 thematic sections\n- Added practical examples for each principle\n- Included learning resources and references\n\n---\n\n# Guile/Scheme Gotchas and Common Mistakes\n\nThis document tracks mistakes we've actually made during development, sorted by frequency.\n\n**Format**: Each gotcha includes:\n- **Count**: Number of times we've hit this issue (kept up-to-date)\n- **The Mistake**: What we did wrong\n- **Why It Failed**: Technical explanation\n- **The Fix**: Correct approach\n- **When to Watch For**: Situations where this mistake is likely\n\n---\n\n## Gotcha Leaderboard (Sorted by Frequency)\n\n### [Count: 3] Missing SRFI-1 Import\n\n**The Mistake:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match))\n\n;; Later in code:\n(let ((filtered (filter-map some-fn items)))  ; ERROR!\n  ...)\n```\n\n**Why It Failed:**\n```\nERROR: Unbound variable: filter-map\n```\n\nList processing functions like `filter-map`, `fold`, `take`, `take-right`, etc. are not part of core Guile - they come from SRFI-1.\n\n**The Fix:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (srfi srfi-1))  ; REQUIRED for list functions\n```\n\n**When to Watch For:**\n- Using any list function beyond basic `car`, `cdr`, `cons`, `append`\n- Processing collections with `filter-map`, `fold`, `partition`\n- Taking slices with `take`, `drop`, `take-right`, `drop-right`\n\n**Frequency Notes:**\n- 2024-11-14: Initial occurrence (guile-config-helper.scm)\n- 2024-11-14: bootstrap-postinstall.scm (take/take-right)\n- 2024-11-15: Future occurrence tracking starts here\n\n---\n\n### [Count: 2] Wrong Shebang for Piped Execution\n\n**The Mistake:**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\nWhen piped: `curl ... | guile`\n\n**Why It Failed:**\n```\n;;; In procedure primitive-load:\n;;; No such file or directory: \"/home/durant/-\"\n```\n\nThe `-s` flag tells Guile to expect a script filename argument. When piped, leftover `-` from arguments gets interpreted as a file path.\n\n**The Fix:**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n**When to Watch For:**\n- Creating scripts meant to be piped via curl\n- Scripts that should read from stdin\n- Bootstrap/installer scripts\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm initial shebang\n- 2024-11-15: Fixed by removing -s flag\n\n---\n\n### [Count: 2] Using macOS Commands on Guix\n\n**The Mistake:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"shasum -a 256 ~s\" filepath)))\n         ...))\n```\n\n**Why It Failed:**\n```\n/gnu/store/.../bash: line 1: shasum: command not found\n```\n\n`shasum` is a BSD/macOS tool. Guix systems use GNU coreutils which provides `sha256sum`.\n\n**The Fix:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"sha256sum ~s\" filepath)))\n         ...))\n```\n\n**When to Watch For:**\n- Porting scripts from macOS development to Guix deployment\n- Using BSD-specific commands: `shasum`, `md5`, `gstat`, etc.\n- Always use GNU coreutils equivalents: `sha256sum`, `md5sum`, `stat`\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm checksum function\n- 2024-11-15: Will likely happen again when porting more scripts\n\n---\n\n### [Count: 1] Reading Only First S-expression\n\n**The Mistake:**\n```scheme\n(define (read-config filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (read port))))  ; ONLY READS FIRST FORM!\n```\n\n**Why It Failed:**\nGuix config files have multiple top-level S-expressions:\n```scheme\n(use-modules (gnu))  ; First form\n(use-modules (gnu services networking))  ; Second form\n(operating-system ...)  ; Third form\n```\n\nOnly got `(use-modules (gnu))`, missing the rest!\n\n**The Fix:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**When to Watch For:**\n- Reading Guix config files (always have multiple use-modules + operating-system)\n- Processing Scheme files with multiple top-level definitions\n- Any file that's more than a single S-expression\n\n**Frequency Notes:**\n- 2024-11-14: guile-config-helper.scm initial implementation\n\n---\n\n### [Count: 1] Wrong Invocation for Piped Scripts\n\n**The Mistake:**\n```bash\ncurl ... | guile --no-auto-compile -s -\n```\n\n**Why It Failed:**\nThe `-s -` combination causes Guile to look for a script file named `-`, leading to path resolution errors.\n\n**The Fix:**\n```bash\ncurl ... | guile\n```\n\nWith the correct shebang (backslash continuation, no `-s`), Guile reads from stdin automatically.\n\n**When to Watch For:**\n- One-liner bootstrap commands\n- Documentation examples for piped execution\n- CI/CD scripts that download and run Guile code\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm documentation\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted gotchas from GUILE_KNOWLEDGE.md\n- Established frequency tracking system\n- Sorted by count (highest first)\n- Added 5 initial gotchas with counts\n\n### Frequency Tracking Protocol\n\nWhen you encounter a gotcha:\n\n1. **If it's already listed**: Increment the count, add date note\n2. **If it's new**: Add it with `[Count: 1]`, insert in sorted position\n3. **Periodically re-sort**: Keep highest-frequency gotchas at top\n4. **Update notes**: Add specific occurrence details to help identify patterns\n\nThis ensures the most common mistakes are always visible first!\n\n---\n\n# Guile Conversion Plan\n\n## Overview\n\nWe're systematically converting all shell scripts that run on Guix systems to Guile Scheme. This provides:\n\n- **Proper S-expression handling** for config.scm manipulation\n- **Type safety** and better error handling\n- **Consistency** with Guix's native language\n- **Maintainability** through structured code\n- **Future-proofing** for advanced Guix features\n\n## Conversion Strategy\n\n### Phase 1: Library Infrastructure (COMPLETED)\n- âœ… Created `lib/guile-config-helper.scm` for S-expression manipulation\n- âœ… Set up Guile testing in Docker\n- âœ… Created test framework in `lib/tests/`\n- âœ… Verified Guile integration with existing Go/shell tests\n\n### Phase 2: Postinstall Scripts (IN PROGRESS)\nConvert postinstall customization scripts to use Guile helper:\n\n1. Update `framework-dual/postinstall/customize` to use Guile helper\n2. Create similar for other platforms\n3. Test GNOME, NetworkManager, SSH configurations\n\n### Phase 3: Critical Installation Scripts (PLANNED)\nConvert lib/*.sh scripts to Guile:\n\nPriority order (by complexity and criticality):\n\n1. **lib/postinstall.sh** (744B) - Simplest, good starting point\n   - Channel generation utilities\n   - Used by customize scripts\n\n2. **lib/clean-install.sh** (3.0K) - Medium complexity\n   - Clean installation wrapper\n   - Calls into Go installer\n\n3. **lib/verify-guix-install.sh** (8.2K) - Complex verification\n   - Post-install verification\n   - System checks\n\n4. **lib/bootstrap-installer.sh** (7.6K) - Bootstrap logic\n   - Downloads and verifies repo\n   - Builds Go installer\n\n5. **lib/recovery-complete-install.sh** (13K) - Most complex\n   - Recovery scenarios\n   - Multiple installation paths\n\n6. **lib/channel-utils.sh** (6.8K) - Channel management\n   - Mirror selection\n   - Channel configuration\n\n### Phase 4: Integration and Testing\n- Update all platform READMEs\n- Create comprehensive Guile test suite\n- Docker testing for all conversions\n- Update documentation\n\n## Conversion Guidelines\n\n### Shebang for Guile Scripts on Guix\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n### Module Structure\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (ice-9 rdelim)\n             (srfi srfi-1)\n             (srfi srfi-26))  ; cut/cute for partial application\n```\n\n### Common Patterns\n\n#### Bash â†’ Guile\n\n**Command execution:**\n```bash\n# Bash\noutput=$(command arg1 arg2)\nif [ $? -eq 0 ]; then\n    echo \"Success\"\nfi\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 popen) (ice-9 rdelim))\n\n(let* ((port (open-input-pipe \"command arg1 arg2\"))\n       (output (read-string port))\n       (status (close-pipe port)))\n  (if (zero? status)\n      (display \"Success\\n\")))\n```\n\n**File operations:**\n```bash\n# Bash\nif [ -f \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n```\n\n```scheme\n;; Guile\n(when (file-exists? file)\n  (let ((content (call-with-input-file file read-string)))\n    ...))\n```\n\n**Argument parsing:**\n```bash\n# Bash\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --flag) FLAG=true; shift ;;\n        *) ARG=$1; shift ;;\n    esac\ndone\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 getopt-long))\n\n(define option-spec\n  '((flag (single-char #\\f) (value #f))\n    (arg (single-char #\\a) (value #t))))\n\n(let ((options (getopt-long (command-line) option-spec)))\n  (define flag (option-ref options 'flag #f))\n  (define arg (option-ref options 'arg #f))\n  ...)\n```\n\n## Testing Requirements\n\nEach converted script must have:\n\n1. **Unit tests** in `lib/tests/test-<script-name>.scm`\n2. **Integration tests** verifying behavior matches bash version\n3. **Docker tests** ensuring Guile dependencies are available\n4. **Documentation** explaining any behavior changes\n\n## Status Tracking\n\n| Script | Lines | Status | Tests | Notes |\n|--------|-------|--------|-------|-------|\n| guile-config-helper.scm | 169 | âœ… Done | âœ… Passing | S-expression manipulation |\n| postinstall.sh | 31 | ðŸ”„ Next | â¸ï¸ Pending | Channel utilities |\n| clean-install.sh | 134 | â¸ï¸ Planned | â¸ï¸ Pending | Installation wrapper |\n| verify-guix-install.sh | 305 | â¸ï¸ Planned | â¸ï¸ Pending | Verification checks |\n| bootstrap-installer.sh | 267 | â¸ï¸ Planned | â¸ï¸ Pending | Bootstrap logic |\n| recovery-complete-install.sh | 458 | â¸ï¸ Planned | â¸ï¸ Pending | Recovery flows |\n| channel-utils.sh | 235 | â¸ï¸ Planned | â¸ï¸ Pending | Channel/mirror selection |\n\n## Migration Path\n\nFor each script:\n\n1. **Analyze** - Understand current bash implementation\n2. **Design** - Plan Guile equivalent with better structure\n3. **Implement** - Write .scm version alongside .sh\n4. **Test** - Comprehensive testing in Docker + real Guix\n5. **Document** - Update all references and docs\n6. **Deploy** - Switch references from .sh to .scm\n7. **Deprecate** - Mark .sh as deprecated\n8. **Remove** - Delete .sh after stable period\n\n## Notes\n\n- **Coexistence**: .sh and .scm versions will coexist during transition\n- **Testing**: Both versions tested until .scm proven stable\n- **Rollback**: Keep .sh versions until all platforms verified\n- **Knowledge Base**: See [GUILE_KNOWLEDGE.md](GUILE_KNOWLEDGE.md) for lessons learned and best practices\n- **Read First**: Review GUILE_KNOWLEDGE.md before starting any Guile development work\n\n\n---\n\nORIGINAL SCRIPT PATH: postinstall/recipes/add-doom-emacs.sh\n\nORIGINAL SCRIPT CONTENT:\n\n#!/usr/bin/env bash\n# Shared recipe: Install and configure Doom Emacs\n# Can be called from any platform's customize tool\n\nset -euo pipefail\n\nCONFIG_FILE=\"${CONFIG_FILE:-/etc/config.scm}\"\n\n# Colors\ninfo() { printf \"  %s\\n\" \"$*\"; }\nwarn() { printf \"\\n\\033[1;33m[warn]\\033[0m %s\\n\" \"$*\"; }\nsuccess() { printf \"\\n\\033[1;32m[OK]\\033[0m %s\\n\" \"$*\"; }\n\nadd_doom_emacs() {\n  echo \"\"\n  echo \"=== Installing Doom Emacs ===\"\n  echo \"\"\n\n  # Check if Emacs is already installed\n  if ! grep -q \"emacs\" \"$CONFIG_FILE\"; then\n    info \"Adding Emacs package to config.scm...\"\n\n    # Add package modules if not present\n    if ! grep -q \"gnu packages emacs\" \"$CONFIG_FILE\"; then\n      sed -i '/(use-modules/a\\             (gnu packages emacs)\\n             (gnu packages version-control)\\n             (gnu packages rust-apps))' \"$CONFIG_FILE\"\n    fi\n\n    # Add emacs and doom dependencies to packages\n    if grep -q \"(packages %base-packages)\" \"$CONFIG_FILE\"; then\n      # Minimal config - expand to use append\n      sed -i 's|(packages %base-packages)|(packages\\n  (append\\n   (list emacs\\n         git\\n         ripgrep\\n         fd)\\n   %base-packages))|' \"$CONFIG_FILE\"\n    else\n      # Already has packages list, add to it\n      sed -i '/(packages/,/))/ { /list/ { s/list/list emacs\\n         git\\n         ripgrep\\n         fd/ } }' \"$CONFIG_FILE\"\n    fi\n\n    info \"Emacs and dependencies added to configuration\"\n  else\n    info \"Emacs already in configuration\"\n  fi\n\n  # Ask if user wants to import existing config\n  echo \"\"\n  read -r -p \"Do you have an existing Doom Emacs config to import? [y/N] \" import_config </dev/tty\n\n  if [[ \"$import_config\" =~ ^[Yy]$ ]]; then\n    echo \"\"\n    info \"Import options:\"\n    info \"  1. Git repository URL\"\n    info \"  2. Skip import (install fresh, import manually later)\"\n    echo \"\"\n    read -r -p \"Enter choice [1-2]: \" choice </dev/tty\n\n    case \"$choice\" in\n      1)\n        read -r -p \"Enter Git repository URL (e.g., https://github.com/user/doom-config): \" repo_url </dev/tty\n        if [[ -n \"$repo_url\" ]]; then\n          info \"Will import config from: $repo_url\"\n          IMPORT_DOOM_CONFIG=\"$repo_url\"\n        else\n          warn \"No URL provided, will create default config\"\n        fi\n        ;;\n      2)\n        info \"Skipping import - you can manually import later\"\n        info \"See: ~/guix-customize/EMACS_IMPORT_GUIDE.md\"\n        ;;\n      *)\n        warn \"Invalid choice, will create default config\"\n        ;;\n    esac\n  fi\n\n  # Install Doom Emacs framework\n  info \"Installing Doom Emacs to ~/.config/emacs...\"\n\n  if [[ -d \"$HOME/.config/emacs\" ]] || [[ -d \"$HOME/.emacs.d\" ]]; then\n    warn \"Existing Emacs configuration found\"\n    read -r -p \"Backup and replace with Doom Emacs? [y/N] \" ans </dev/tty\n    if [[ \"$ans\" =~ ^[Yy]$ ]]; then\n      [[ -d \"$HOME/.config/emacs\" ]] && mv \"$HOME/.config/emacs\" \"$HOME/.config/emacs.backup.$(date +%Y%m%d-%H%M%S)\"\n      [[ -d \"$HOME/.emacs.d\" ]] && mv \"$HOME/.emacs.d\" \"$HOME/.emacs.d.backup.$(date +%Y%m%d-%H%M%S)\"\n      info \"Backed up existing Emacs configuration\"\n    else\n      info \"Skipping Doom Emacs installation\"\n      return 0\n    fi\n  fi\n\n  # Clone Doom Emacs framework\n  git clone --depth 1 https://github.com/doomemacs/doomemacs \"$HOME/.config/emacs\"\n\n  # Install Doom\n  info \"Running Doom installer...\"\n  \"$HOME/.config/emacs/bin/doom\" install --no-env --no-fonts\n\n  # Import user's config or create default\n  mkdir -p \"$HOME/.config/doom\"\n\n  if [[ -n \"$IMPORT_DOOM_CONFIG\" ]]; then\n    info \"Importing your Doom config from repository...\"\n    if git clone \"$IMPORT_DOOM_CONFIG\" \"$HOME/.config/doom.tmp\"; then\n      mv \"$HOME/.config/doom.tmp\"/* \"$HOME/.config/doom/\"\n      rm -rf \"$HOME/.config/doom.tmp\"\n      success \"Config imported successfully!\"\n      info \"Running doom sync to install packages...\"\n      \"$HOME/.config/emacs/bin/doom\" sync\n    else\n      warn \"Failed to clone repository, creating default config instead\"\n      IMPORT_DOOM_CONFIG=\"\"\n    fi\n  fi\n\n  if [[ -z \"$IMPORT_DOOM_CONFIG\" ]] && [[ ! -f \"$HOME/.config/doom/init.el\" ]]; then\n    info \"Creating basic Doom configuration...\"\n    cat > \"$HOME/.config/doom/init.el\" <<'EOF'\n;;; init.el -*- lexical-binding: t; -*-\n\n(doom! :input\n\n       :completion\n       company\n       vertico\n\n       :ui\n       doom\n       doom-dashboard\n       hl-todo\n       modeline\n       ophints\n       (popup +defaults)\n       treemacs\n       vc-gutter\n       vi-tilde-fringe\n       workspaces\n\n       :editor\n       (evil +everywhere)\n       file-templates\n       fold\n       (format +onsave)\n       multiple-cursors\n       rotate-text\n       snippets\n\n       :emacs\n       dired\n       electric\n       ibuffer\n       undo\n       vc\n\n       :term\n       vterm\n\n       :checkers\n       syntax\n\n       :tools\n       (eval +overlay)\n       lookup\n       lsp\n       magit\n       make\n       tree-sitter\n\n       :os\n       (:if IS-MAC macos)\n       tty\n\n       :lang\n       (cc +lsp)\n       data\n       emacs-lisp\n       (go +lsp)\n       (javascript +lsp)\n       json\n       (markdown +grip)\n       (org +pretty)\n       (python +lsp)\n       (rust +lsp)\n       sh\n       web\n       yaml\n\n       :email\n\n       :app\n\n       :config\n       (default +bindings +smartparens))\nEOF\n  fi\n\n  if [[ ! -f \"$HOME/.config/doom/config.el\" ]]; then\n    cat > \"$HOME/.config/doom/config.el\" <<'EOF'\n;;; config.el -*- lexical-binding: t; -*-\n\n;; Basic settings\n(setq user-full-name \"Your Name\"\n      user-mail-address \"your@email.com\")\n\n;; Theme\n(setq doom-theme 'doom-one)\n\n;; Line numbers\n(setq display-line-numbers-type 'relative)\n\n;; Font\n(setq doom-font (font-spec :family \"monospace\" :size 14))\nEOF\n  fi\n\n  if [[ ! -f \"$HOME/.config/doom/packages.el\" ]]; then\n    cat > \"$HOME/.config/doom/packages.el\" <<'EOF'\n;; -*- no-byte-compile: t; -*-\n;;; packages.el\n\n;; Add your custom packages here\nEOF\n  fi\n\n  success \"Doom Emacs installation complete!\"\n  echo \"\"\n  info \"Next steps:\"\n  info \"  1. Apply config: sudo guix system reconfigure /etc/config.scm\"\n  if [[ -z \"$IMPORT_DOOM_CONFIG\" ]]; then\n    info \"  2. Run: ~/.config/emacs/bin/doom sync\"\n    info \"  3. Launch Emacs to complete setup\"\n  else\n    info \"  2. Launch Emacs (packages already synced)\"\n  fi\n  echo \"\"\n  info \"Doom Emacs quick start:\"\n  info \"  SPC f f - Find file\"\n  info \"  SPC p f - Find file in project\"\n  info \"  SPC b b - Switch buffer\"\n  info \"  SPC w v - Split window vertically\"\n  info \"  SPC w s - Split window horizontally\"\n  info \"  SPC q q - Quit\"\n  echo \"\"\n  if [[ -z \"$IMPORT_DOOM_CONFIG\" ]]; then\n    info \"To import your config later, see: ~/guix-customize/EMACS_IMPORT_GUIDE.md\"\n  fi\n  info \"Documentation: https://docs.doomemacs.org\"\n  echo \"\"\n}\n\n# Run if called directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n  add_doom_emacs\nfi\n\n\n---\n\nCONVERSION REQUIREMENTS:\n\n1. Use proper Guile shebang: #!/run/current-system/profile/bin/guile --no-auto-compile -s\n2. Include all necessary use-modules (ice-9 popen, ice-9 rdelim, ice-9 format, srfi srfi-1)\n3. Convert all bash functions to Guile procedures\n4. Use Guile idioms: call-with-input-file, open-input-pipe, etc.\n5. Maintain all functionality from the original script\n6. Add comments explaining complex conversions\n7. Follow naming conventions: predicates end in ?, mutators end in !\n8. Use tail recursion where appropriate\n9. Use GNU coreutils commands (sha256sum not shasum, etc.)\n\nOUTPUT FORMAT:\n\nProvide ONLY the complete converted Guile script. No explanations, no markdown formatting, just the raw .scm file content starting with the shebang.\n"
      }
    ]
  }
}

{
  "custom_id": "convert-postinstall-recipes-add-fonts",
  "params": {
    "model": "claude-sonnet-4-5",
    "max_tokens": 8192,
    "messages": [
      {
        "role": "user",
        "content": "Convert this bash script to Guile Scheme following the documentation provided.\n\nREFERENCE DOCUMENTATION:\n\n# GUILE KNOWLEDGE BASE\n\n# Guile Development Knowledge Base\n\n**Purpose**: Central index for Guile Scheme development knowledge in this project.\n\n**Read this before**: Starting any new Guile script or modifying existing .scm files.\n\n---\n\n## Quick Navigation\n\n### ðŸ“š [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md)\nBest practices and design patterns for writing maintainable Guile code.\n\n**Topics:**\n- Module system usage\n- Separation of concerns (REPL/Script/Library)\n- Pure functional style\n- Tail recursion patterns\n- Incremental development\n- Code readability and naming\n- Abstraction levels\n- Performance optimization\n- Scheme conventions\n- Error handling\n\n**Read this**: When designing new functions or refactoring existing code.\n\n---\n\n### âš ï¸  [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md)\nCommon mistakes sorted by frequency (most common first).\n\n**Current top gotchas:**\n1. Missing SRFI-1 import (Count: 3)\n2. Wrong shebang for piped execution (Count: 2)\n3. Using macOS commands on Guix (Count: 2)\n4. Reading only first S-expression (Count: 1)\n5. Wrong invocation for piped scripts (Count: 1)\n\n**Read this**: When you encounter an error, or before writing similar code patterns.\n\n---\n\n## Guile Quick Reference (This Project)\n\n### Standard Shebang for Standalone Scripts\n\n**For regular scripts (executed directly):**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n**For scripts meant to be piped (bootstrap scripts):**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n### Essential Imports\n\n**Minimum for most scripts:**\n```scheme\n(use-modules (ice-9 popen)       ; Command execution\n             (ice-9 rdelim)      ; Line reading\n             (ice-9 format)      ; String formatting\n             (srfi srfi-1))      ; List processing\n```\n\n**For S-expression manipulation:**\n```scheme\n(use-modules (ice-9 pretty-print) ; Pretty-print S-exprs\n             (ice-9 match)        ; Pattern matching\n             (srfi srfi-1))       ; List functions\n```\n\n### Common Patterns\n\n**Reading all S-expressions from a file:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**Executing shell command and capturing output:**\n```scheme\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (values output status)))\n```\n\n**Pattern matching on S-expressions:**\n```scheme\n(use-modules (ice-9 match))\n\n(match expr\n  (('operating-system fields ...)\n   ;; Handle operating-system form\n   ...)\n  (('use-modules modules ...)\n   ;; Handle use-modules form\n   ...)\n  (else\n   ;; Default case\n   ...))\n```\n\n---\n\n## Testing Strategy\n\n### REPL-Driven Development\n\n1. Start Guile REPL: `guile`\n2. Load your module: `(load \"lib/my-script.scm\")`\n3. Test functions interactively\n4. Fix issues and reload\n5. Once working, extract to clean script\n\n### Integration Testing\n\n**For config manipulation:**\n```bash\n# Test with sample config file\nframework-dual/postinstall/tests/run-guile-tests.sh\n```\n\n**For bootstrap scripts:**\n```bash\n# Test in Docker environment\n./test-docker.sh test\n```\n\n---\n\n## File I/O Reference\n\n### Reading Files\n\n```scheme\n;; Read entire file as string\n(call-with-input-file \"path/to/file\" read-string)\n\n;; Read all S-expressions\n(call-with-input-file \"config.scm\"\n  (lambda (port)\n    (let loop ((exprs '()))\n      (let ((expr (read port)))\n        (if (eof-object? expr)\n            (reverse exprs)\n            (loop (cons expr exprs)))))))\n\n;; Read line by line\n(call-with-input-file \"path/to/file\"\n  (lambda (port)\n    (let loop ((lines '()))\n      (let ((line (read-line port)))\n        (if (eof-object? line)\n            (reverse lines)\n            (loop (cons line lines)))))))\n```\n\n### Writing Files\n\n```scheme\n;; Write string to file\n(call-with-output-file \"path/to/file\"\n  (lambda (port)\n    (display \"content\" port)))\n\n;; Pretty-print S-expression to file\n(call-with-output-file \"config.scm\"\n  (lambda (port)\n    (pretty-print expr port)))\n```\n\n---\n\n## Shell Integration\n\n### Running Commands\n\n```scheme\n;; Simple command execution (return status)\n(system \"ls -la\")  ; Returns exit code\n\n;; Execute with proper error handling\n(define (system* cmd)\n  (let ((status (system cmd)))\n    (zero? status)))\n\n;; Capture output\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (if (zero? status)\n        output\n        #f)))\n```\n\n### Platform-Specific Commands\n\n**ALWAYS use GNU coreutils on Guix:**\n- âœ… `sha256sum` (NOT `shasum`)\n- âœ… `md5sum` (NOT `md5`)\n- âœ… `stat` (NOT `gstat`)\n\nSee [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md#count-2-using-macos-commands-on-guix) for details.\n\n---\n\n## When to Use Guile vs Bash\n\n### Use Guile when:\n- Manipulating S-expressions (config.scm files)\n- Complex data transformations\n- Need proper error handling\n- Cross-platform script requirements\n\n### Use Bash when:\n- Simple file operations\n- Gluing together CLI tools\n- Quick one-liners\n- Temporary helper scripts\n\n### Use Guile from Bash:\n```bash\n# Call Guile helper from bash\nguile_add_service() {\n  local module=\"$1\"\n  local service=\"$2\"\n\n  guile --no-auto-compile -s lib/guile-config-helper.scm \\\n    add-service /etc/config.scm \"$module\" \"$service\"\n}\n```\n\n---\n\n## Resources\n\n### Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Learning Resources\n- [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n- [The Guile Hacker's Notebook](https://jeko.frama.io/)\n- [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\n- [System Crafters Community](https://systemcrafters.net/)\n\n### Project-Specific\n- [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md) - Design patterns and coding standards\n- [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md) - Common mistakes (frequency-sorted)\n- [GUILE_CONVERSION.md](GUILE_CONVERSION.md) - Bash-to-Guile conversion strategy\n- [POSTINSTALL_DEV.md](POSTINSTALL_DEV.md) - Postinstall development workflow\n\n---\n\n## Changelog\n\n### 2024-11-15: Major Reorganization\n- Split into three focused files:\n  - GUILE_KNOWLEDGE.md (this file): Quick reference and index\n  - GUILE_BEST_PRACTICES.md: Design patterns and principles\n  - GUILE_GOTCHAS.md: Common mistakes with frequency tracking\n- Streamlined content to be a practical quick reference\n- Added navigation guide and file purposes\n\n### 2024-11-14: Enhanced with Community Resources\n- Added best practice themes (moved to GUILE_BEST_PRACTICES.md)\n- Added recommended learning resources\n- Documented common mistakes (moved to GUILE_GOTCHAS.md)\n\n### 2024-11-14: Initial Creation\n- Documented \"read all S-expressions\" mistake\n- Documented SRFI-1 import requirement\n- Added shebang best practices\n- Added pattern matching guide\n- Added file I/O patterns\n- Added testing strategies\n- Added shell integration patterns\n\n---\n\n# Guile/Scheme Best Practices\n\nBest practices and design patterns for writing maintainable Guile code.\n\nBased on:\n- Community resources (Guile Hacker's Notebook, Wingolog, System Crafters)\n- Functional programming principles\n- Real-world experience from this project\n\nFor common mistakes, see [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md).\n\n---\n\n## Table of Contents\n\n1. [Module System](#1-use-the-module-system-properly)\n2. [Separation of Concerns](#2-separate-concerns-repl-script-library)\n3. [Pure Functional Style](#3-prefer-pure-functional-definitions)\n4. [Tail Recursion](#4-use-tail-calls-and-recursion-carefully)\n5. [Incremental Development](#5-write-tests-and-develop-incrementally)\n6. [Code Readability](#6-code-readability-and-naming)\n7. [Abstraction Levels](#7-use-appropriate-abstraction-levels)\n8. [Performance](#8-mind-performance-when-needed)\n9. [Scheme Conventions](#9-follow-scheme-conventions)\n10. [Error Handling](#10-handle-errors-gracefully)\n\n---\n\n## 1. Use the Module System Properly\n\nStructure code into modules with clear interfaces rather than one giant file:\n\n```scheme\n;; lib/my-module.scm\n(define-module (my-module)\n  #:use-module (ice-9 match)\n  #:use-module (srfi srfi-1)\n  #:export (public-function another-function))\n\n(define (public-function arg)\n  ;; Exported, available to other modules\n  ...)\n\n(define (private-helper arg)\n  ;; Not exported, internal only\n  ...)\n```\n\n**When to use modules:**\n- Reusable code across multiple scripts\n- Clear public/private API boundaries\n- Logical grouping of related functions\n\n**When to use standalone scripts:**\n- Single-purpose tools (like our config helpers)\n- Easier distribution (one file)\n- Simpler for end users\n\n---\n\n## 2. Separate Concerns: REPL, Script, Library\n\n- **Library code**: Pure functions, no I/O, easily testable\n- **Script code**: Thin wrapper that handles I/O and calls library\n- **REPL experimentation**: Interactive development, then extract to library\n\n```scheme\n;; Library: pure logic\n(define (calculate-sum items)\n  (fold + 0 items))\n\n;; Script: I/O wrapper\n(define (main args)\n  (let ((numbers (read-numbers-from-file \"input.txt\")))\n    (display (calculate-sum numbers))))\n```\n\n---\n\n## 3. Prefer Pure Functional Definitions\n\nKeep side-effects isolated (I/O, mutation) so bulk of logic is easy to reason about:\n\n```scheme\n;; Good: pure function\n(define (add-service-to-list services new-service)\n  (if (member new-service services)\n      services\n      (cons new-service services)))\n\n;; Avoid: mutation\n(define (add-service-mutating! services new-service)\n  (set! services (cons new-service services)))  ; Don't do this\n```\n\n**Benefits:**\n- Easier to test (no setup/teardown needed)\n- Easier to reason about (no hidden state)\n- Composable (pure functions combine cleanly)\n- Parallelizable (no shared mutable state)\n\n---\n\n## 4. Use Tail Calls and Recursion Carefully\n\nScheme supports proper tail recursion - use it to avoid stack blow-ups:\n\n```scheme\n;; Good: tail recursive (constant stack)\n(define (sum-list lst)\n  (let loop ((items lst) (acc 0))\n    (if (null? items)\n        acc\n        (loop (cdr items) (+ acc (car items))))))\n\n;; Bad: not tail recursive (grows stack)\n(define (sum-list-bad lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (sum-list-bad (cdr lst)))))\n```\n\n**Common tail-recursive patterns:**\n- Named `let` for loops\n- Accumulator parameter for results\n- Always recurse as last operation\n\n**When recursion is appropriate:**\n- Processing lists or trees\n- State machines\n- Iterative algorithms\n\n**When to use built-in functions instead:**\n- `fold`, `map`, `filter` are already optimized\n- More readable than manual recursion\n- Less error-prone\n\n---\n\n## 5. Write Tests and Develop Incrementally\n\n- Write small modules\n- Test via REPL\n- Build up incrementally\n- Keep examples in comments\n\n```scheme\n;; Example usage in comments:\n;; (add-service '(service foo) '(service bar))\n;; => '(service foo service bar)\n\n(define (add-service services new-service)\n  ...)\n```\n\n**Development workflow:**\n\n1. Start in REPL with small test cases\n2. Extract working code to functions\n3. Add docstrings and examples\n4. Create test files for regression testing\n5. Refactor once tests pass\n\n---\n\n## 6. Code Readability and Naming\n\nScheme has minimal syntax - good naming matters even more:\n\n```scheme\n;; Good: descriptive names\n(define (find-operating-system-expr exprs)\n  (find (lambda (expr)\n          (and (pair? expr)\n               (eq? (car expr) 'operating-system)))\n        exprs))\n\n;; Bad: unclear names\n(define (find-os x)\n  (find (lambda (e) (and (pair? e) (eq? (car e) 'operating-system))) x))\n```\n\n**Naming conventions:**\n- Predicates end in `?`: `empty?`, `file-exists?`\n- Mutators end in `!`: `set!`, `delete-file!`\n- Converters use `->`: `string->number`, `list->vector`\n- Use full words, not abbreviations\n- Be consistent with Scheme stdlib naming\n\n**Formatting:**\n- Indent consistently (2 spaces per level)\n- Align closing parens vertically\n- Break long expressions across lines\n- Group related functions together\n\n---\n\n## 7. Use Appropriate Abstraction Levels\n\nHigher-order functions, closures, macros - use when they improve clarity:\n\n```scheme\n;; Good: clear intent with higher-order function\n(filter (lambda (x) (> x 0)) numbers)\n\n;; Overkill: macro where function suffices\n(define-syntax when-positive  ; Don't do this for simple case\n  (syntax-rules ()\n    ((when-positive x body ...)\n     (if (> x 0) (begin body ...)))))\n```\n\n**Abstraction ladder:**\n\n1. **Direct code**: Simplest, most explicit\n2. **Helper functions**: Reduce duplication\n3. **Higher-order functions**: Parameterize behavior\n4. **Macros**: Create new syntax (use sparingly!)\n\n**When to create abstractions:**\n- Pattern appears 3+ times\n- Logic is complex and benefits from naming\n- Future changes will be localized\n\n**When NOT to abstract:**\n- One-off code\n- Abstraction obscures intent\n- Too early (wait for real duplication)\n\n---\n\n## 8. Mind Performance When Needed\n\n- Use tail recursion to avoid stack growth\n- Avoid quadratic operations (repeated `append`)\n- Consider compilation for frequently-run code\n- Profile before optimizing\n\n```scheme\n;; Slow: O(nÂ²) with repeated append\n(let loop ((items input) (result '()))\n  (if (null? items)\n      result\n      (loop (cdr items) (append result (list (car items))))))\n\n;; Fast: O(n) with cons + reverse\n(reverse\n  (let loop ((items input) (result '()))\n    (if (null? items)\n        result\n        (loop (cdr items) (cons (car items) result)))))\n```\n\n**Common performance pitfalls:**\n- `append` on right side of list (O(n) per call)\n- Deep recursion without tail calls (stack overflow)\n- String concatenation in loops (use `string-append` with list, then join)\n- Repeated `length` calls (cache it if needed)\n\n**Optimization strategy:**\n\n1. Write correct code first\n2. Measure if performance matters\n3. Identify bottlenecks (profiling)\n4. Apply targeted optimizations\n5. Verify correctness still holds\n\n---\n\n## 9. Follow Scheme Conventions\n\nEven with Guile-specific features, stick to Scheme idioms:\n\n**Lexical scope:**\n- Use `let`, `let*`, `letrec` appropriately\n- `let`: bindings don't see each other\n- `let*`: sequential bindings (can reference earlier ones)\n- `letrec`: recursive bindings\n\n**Immutability:**\n- Default to immutable data structures\n- Return new values instead of mutating\n- Use `!` suffix only when truly necessary\n\n**Proper tail calls:**\n- Scheme guarantees tail call optimization\n- Rely on it for iteration\n- No need for explicit loops (unless clearer)\n\n**Closures:**\n- Capture environment for encapsulation\n- Create stateful objects functionally\n- Return functions from functions\n\n---\n\n## 10. Handle Errors Gracefully\n\nProvide helpful error messages with context:\n\n```scheme\n;; Bad: generic error\n(if (not (file-exists? config-file))\n    (error \"File not found\"))\n\n;; Good: specific context\n(if (not (file-exists? config-file))\n    (error (format #f \"Config file not found: ~a\\nExpected at: ~a\"\n                   config-file\n                   (dirname config-file))))\n```\n\n**Error handling strategies:**\n\n**Guard against invalid input:**\n```scheme\n(define (divide a b)\n  (if (zero? b)\n      (error \"Cannot divide by zero\")\n      (/ a b)))\n```\n\n**Validate early:**\n```scheme\n(define (process-config filepath)\n  ;; Validate upfront\n  (unless (file-exists? filepath)\n    (error (format #f \"Config not found: ~a\" filepath)))\n  (unless (access? filepath R_OK)\n    (error (format #f \"Config not readable: ~a\" filepath)))\n\n  ;; Now process\n  ...)\n```\n\n**Provide recovery options:**\n```scheme\n(define (safe-read-config filepath fallback)\n  (if (file-exists? filepath)\n      (call-with-input-file filepath read)\n      fallback))\n```\n\n---\n\n## Resources\n\n### Recommended Learning Resources\n\n#### 1. [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n**The official manual** for Guile, covering how to use it interactively, scripting, modules, debugging, etc.\n\n**Why useful:** Gives you the \"what\" of Guile and how to use the language in practice (not just theory).\n\n**Tip:** Use this as your baseline reference. Whenever you're unsure how to structure a module, script, or use a particular part of the API â€” go here.\n\n#### 2. [The Guile Hacker's Notebook](https://jeko.frama.io/)\nA resource dedicated specifically to Guile: covers concrete programming situations and brings best-practice thinking (TDD, clean code, architecture) into Scheme/Guile.\n\n**Why useful:** Covers how to write maintainable code in Guile, not just syntax.\n\n**Tip:** As you advance from basic syntax into \"how to write maintainable code in Guile\", this is very helpful.\n\n#### 3. [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\nBlog posts and talks by a Guile maintainer. For example: [\"Lessons Learned from Guile, the Ancient & Spry\"](https://wingolog.org/archives/2016/01/11/lessons-learned-from-guile-the-ancient-and-spry)\n\n**Why useful:** Meta-level thinking about how Guile is built and evolves - informs design decisions and best practices.\n\n**Tip:** Use this for understanding \"why\" Guile works the way it does, which helps you make better architecture/style choices.\n\n#### 4. [System Crafters Community Discussions](https://systemcrafters.net/)\nCommunity discussions like \"Is there a good learning material on Guile Scheme?\"\n\n**Why useful:** Honest user reflections - what they found difficult, what worked, common gotchas.\n\n**Tip:** Browse these to see common patterns and pitfalls (especially with modules, REPL, embedding).\n\n### Official Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Quick References\n- Pattern matching: [ice-9 match](https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html)\n- File I/O: [Ports and File Descriptors](https://www.gnu.org/software/guile/manual/html_node/File-Ports.html)\n- Pretty-printing: [ice-9 pretty-print](https://www.gnu.org/software/guile/manual/html_node/Pretty_002dPrinting.html)\n- Tail calls: [Expressions](https://www.gnu.org/software/guile/manual/html_node/Expressions.html)\n- Modules: [Modules](https://www.gnu.org/software/guile/manual/html_node/Modules.html)\n\n### Performance and Optimization\n- [David Thompson: Optimizing Guile](https://dthompson.us/posts/optimize-guile.html)\n- Guile compilation, bytecode, and performance considerations\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted best practices from GUILE_KNOWLEDGE.md\n- Organized into 10 thematic sections\n- Added practical examples for each principle\n- Included learning resources and references\n\n---\n\n# Guile/Scheme Gotchas and Common Mistakes\n\nThis document tracks mistakes we've actually made during development, sorted by frequency.\n\n**Format**: Each gotcha includes:\n- **Count**: Number of times we've hit this issue (kept up-to-date)\n- **The Mistake**: What we did wrong\n- **Why It Failed**: Technical explanation\n- **The Fix**: Correct approach\n- **When to Watch For**: Situations where this mistake is likely\n\n---\n\n## Gotcha Leaderboard (Sorted by Frequency)\n\n### [Count: 3] Missing SRFI-1 Import\n\n**The Mistake:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match))\n\n;; Later in code:\n(let ((filtered (filter-map some-fn items)))  ; ERROR!\n  ...)\n```\n\n**Why It Failed:**\n```\nERROR: Unbound variable: filter-map\n```\n\nList processing functions like `filter-map`, `fold`, `take`, `take-right`, etc. are not part of core Guile - they come from SRFI-1.\n\n**The Fix:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (srfi srfi-1))  ; REQUIRED for list functions\n```\n\n**When to Watch For:**\n- Using any list function beyond basic `car`, `cdr`, `cons`, `append`\n- Processing collections with `filter-map`, `fold`, `partition`\n- Taking slices with `take`, `drop`, `take-right`, `drop-right`\n\n**Frequency Notes:**\n- 2024-11-14: Initial occurrence (guile-config-helper.scm)\n- 2024-11-14: bootstrap-postinstall.scm (take/take-right)\n- 2024-11-15: Future occurrence tracking starts here\n\n---\n\n### [Count: 2] Wrong Shebang for Piped Execution\n\n**The Mistake:**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\nWhen piped: `curl ... | guile`\n\n**Why It Failed:**\n```\n;;; In procedure primitive-load:\n;;; No such file or directory: \"/home/durant/-\"\n```\n\nThe `-s` flag tells Guile to expect a script filename argument. When piped, leftover `-` from arguments gets interpreted as a file path.\n\n**The Fix:**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n**When to Watch For:**\n- Creating scripts meant to be piped via curl\n- Scripts that should read from stdin\n- Bootstrap/installer scripts\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm initial shebang\n- 2024-11-15: Fixed by removing -s flag\n\n---\n\n### [Count: 2] Using macOS Commands on Guix\n\n**The Mistake:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"shasum -a 256 ~s\" filepath)))\n         ...))\n```\n\n**Why It Failed:**\n```\n/gnu/store/.../bash: line 1: shasum: command not found\n```\n\n`shasum` is a BSD/macOS tool. Guix systems use GNU coreutils which provides `sha256sum`.\n\n**The Fix:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"sha256sum ~s\" filepath)))\n         ...))\n```\n\n**When to Watch For:**\n- Porting scripts from macOS development to Guix deployment\n- Using BSD-specific commands: `shasum`, `md5`, `gstat`, etc.\n- Always use GNU coreutils equivalents: `sha256sum`, `md5sum`, `stat`\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm checksum function\n- 2024-11-15: Will likely happen again when porting more scripts\n\n---\n\n### [Count: 1] Reading Only First S-expression\n\n**The Mistake:**\n```scheme\n(define (read-config filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (read port))))  ; ONLY READS FIRST FORM!\n```\n\n**Why It Failed:**\nGuix config files have multiple top-level S-expressions:\n```scheme\n(use-modules (gnu))  ; First form\n(use-modules (gnu services networking))  ; Second form\n(operating-system ...)  ; Third form\n```\n\nOnly got `(use-modules (gnu))`, missing the rest!\n\n**The Fix:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**When to Watch For:**\n- Reading Guix config files (always have multiple use-modules + operating-system)\n- Processing Scheme files with multiple top-level definitions\n- Any file that's more than a single S-expression\n\n**Frequency Notes:**\n- 2024-11-14: guile-config-helper.scm initial implementation\n\n---\n\n### [Count: 1] Wrong Invocation for Piped Scripts\n\n**The Mistake:**\n```bash\ncurl ... | guile --no-auto-compile -s -\n```\n\n**Why It Failed:**\nThe `-s -` combination causes Guile to look for a script file named `-`, leading to path resolution errors.\n\n**The Fix:**\n```bash\ncurl ... | guile\n```\n\nWith the correct shebang (backslash continuation, no `-s`), Guile reads from stdin automatically.\n\n**When to Watch For:**\n- One-liner bootstrap commands\n- Documentation examples for piped execution\n- CI/CD scripts that download and run Guile code\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm documentation\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted gotchas from GUILE_KNOWLEDGE.md\n- Established frequency tracking system\n- Sorted by count (highest first)\n- Added 5 initial gotchas with counts\n\n### Frequency Tracking Protocol\n\nWhen you encounter a gotcha:\n\n1. **If it's already listed**: Increment the count, add date note\n2. **If it's new**: Add it with `[Count: 1]`, insert in sorted position\n3. **Periodically re-sort**: Keep highest-frequency gotchas at top\n4. **Update notes**: Add specific occurrence details to help identify patterns\n\nThis ensures the most common mistakes are always visible first!\n\n---\n\n# Guile Conversion Plan\n\n## Overview\n\nWe're systematically converting all shell scripts that run on Guix systems to Guile Scheme. This provides:\n\n- **Proper S-expression handling** for config.scm manipulation\n- **Type safety** and better error handling\n- **Consistency** with Guix's native language\n- **Maintainability** through structured code\n- **Future-proofing** for advanced Guix features\n\n## Conversion Strategy\n\n### Phase 1: Library Infrastructure (COMPLETED)\n- âœ… Created `lib/guile-config-helper.scm` for S-expression manipulation\n- âœ… Set up Guile testing in Docker\n- âœ… Created test framework in `lib/tests/`\n- âœ… Verified Guile integration with existing Go/shell tests\n\n### Phase 2: Postinstall Scripts (IN PROGRESS)\nConvert postinstall customization scripts to use Guile helper:\n\n1. Update `framework-dual/postinstall/customize` to use Guile helper\n2. Create similar for other platforms\n3. Test GNOME, NetworkManager, SSH configurations\n\n### Phase 3: Critical Installation Scripts (PLANNED)\nConvert lib/*.sh scripts to Guile:\n\nPriority order (by complexity and criticality):\n\n1. **lib/postinstall.sh** (744B) - Simplest, good starting point\n   - Channel generation utilities\n   - Used by customize scripts\n\n2. **lib/clean-install.sh** (3.0K) - Medium complexity\n   - Clean installation wrapper\n   - Calls into Go installer\n\n3. **lib/verify-guix-install.sh** (8.2K) - Complex verification\n   - Post-install verification\n   - System checks\n\n4. **lib/bootstrap-installer.sh** (7.6K) - Bootstrap logic\n   - Downloads and verifies repo\n   - Builds Go installer\n\n5. **lib/recovery-complete-install.sh** (13K) - Most complex\n   - Recovery scenarios\n   - Multiple installation paths\n\n6. **lib/channel-utils.sh** (6.8K) - Channel management\n   - Mirror selection\n   - Channel configuration\n\n### Phase 4: Integration and Testing\n- Update all platform READMEs\n- Create comprehensive Guile test suite\n- Docker testing for all conversions\n- Update documentation\n\n## Conversion Guidelines\n\n### Shebang for Guile Scripts on Guix\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n### Module Structure\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (ice-9 rdelim)\n             (srfi srfi-1)\n             (srfi srfi-26))  ; cut/cute for partial application\n```\n\n### Common Patterns\n\n#### Bash â†’ Guile\n\n**Command execution:**\n```bash\n# Bash\noutput=$(command arg1 arg2)\nif [ $? -eq 0 ]; then\n    echo \"Success\"\nfi\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 popen) (ice-9 rdelim))\n\n(let* ((port (open-input-pipe \"command arg1 arg2\"))\n       (output (read-string port))\n       (status (close-pipe port)))\n  (if (zero? status)\n      (display \"Success\\n\")))\n```\n\n**File operations:**\n```bash\n# Bash\nif [ -f \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n```\n\n```scheme\n;; Guile\n(when (file-exists? file)\n  (let ((content (call-with-input-file file read-string)))\n    ...))\n```\n\n**Argument parsing:**\n```bash\n# Bash\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --flag) FLAG=true; shift ;;\n        *) ARG=$1; shift ;;\n    esac\ndone\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 getopt-long))\n\n(define option-spec\n  '((flag (single-char #\\f) (value #f))\n    (arg (single-char #\\a) (value #t))))\n\n(let ((options (getopt-long (command-line) option-spec)))\n  (define flag (option-ref options 'flag #f))\n  (define arg (option-ref options 'arg #f))\n  ...)\n```\n\n## Testing Requirements\n\nEach converted script must have:\n\n1. **Unit tests** in `lib/tests/test-<script-name>.scm`\n2. **Integration tests** verifying behavior matches bash version\n3. **Docker tests** ensuring Guile dependencies are available\n4. **Documentation** explaining any behavior changes\n\n## Status Tracking\n\n| Script | Lines | Status | Tests | Notes |\n|--------|-------|--------|-------|-------|\n| guile-config-helper.scm | 169 | âœ… Done | âœ… Passing | S-expression manipulation |\n| postinstall.sh | 31 | ðŸ”„ Next | â¸ï¸ Pending | Channel utilities |\n| clean-install.sh | 134 | â¸ï¸ Planned | â¸ï¸ Pending | Installation wrapper |\n| verify-guix-install.sh | 305 | â¸ï¸ Planned | â¸ï¸ Pending | Verification checks |\n| bootstrap-installer.sh | 267 | â¸ï¸ Planned | â¸ï¸ Pending | Bootstrap logic |\n| recovery-complete-install.sh | 458 | â¸ï¸ Planned | â¸ï¸ Pending | Recovery flows |\n| channel-utils.sh | 235 | â¸ï¸ Planned | â¸ï¸ Pending | Channel/mirror selection |\n\n## Migration Path\n\nFor each script:\n\n1. **Analyze** - Understand current bash implementation\n2. **Design** - Plan Guile equivalent with better structure\n3. **Implement** - Write .scm version alongside .sh\n4. **Test** - Comprehensive testing in Docker + real Guix\n5. **Document** - Update all references and docs\n6. **Deploy** - Switch references from .sh to .scm\n7. **Deprecate** - Mark .sh as deprecated\n8. **Remove** - Delete .sh after stable period\n\n## Notes\n\n- **Coexistence**: .sh and .scm versions will coexist during transition\n- **Testing**: Both versions tested until .scm proven stable\n- **Rollback**: Keep .sh versions until all platforms verified\n- **Knowledge Base**: See [GUILE_KNOWLEDGE.md](GUILE_KNOWLEDGE.md) for lessons learned and best practices\n- **Read First**: Review GUILE_KNOWLEDGE.md before starting any Guile development work\n\n\n---\n\nORIGINAL SCRIPT PATH: postinstall/recipes/add-fonts.sh\n\nORIGINAL SCRIPT CONTENT:\n\n#!/usr/bin/env bash\n# Shared recipe: Install common fonts for programming and general use\n# Can be called from any platform's customize tool\n\nset -euo pipefail\n\nCONFIG_FILE=\"${CONFIG_FILE:-/etc/config.scm}\"\n\n# Colors\ninfo() { printf \"  %s\\n\" \"$*\"; }\nsuccess() { printf \"\\n\\033[1;32m[âœ“]\\033[0m %s\\n\" \"$*\"; }\n\nadd_fonts() {\n  echo \"\"\n  echo \"=== Installing Common Fonts ===\"\n  echo \"\"\n\n  info \"Adding font packages to config.scm...\"\n\n  # List of useful fonts\n  local font_packages=(\n    \"font-fira-code\"           # Popular programming font with ligatures\n    \"font-jetbrains-mono\"      # JetBrains programming font\n    \"font-dejavu\"              # DejaVu fonts (good coverage)\n    \"font-liberation\"          # Liberation fonts (metric-compatible with Arial, etc.)\n    \"font-gnu-freefont\"        # GNU FreeFont\n    \"font-awesome\"             # Icon font\n    \"font-google-noto\"         # Google Noto (comprehensive Unicode)\n  )\n\n  # Check if packages section exists\n  if grep -q \"(packages %base-packages)\" \"$CONFIG_FILE\"; then\n    # Minimal config - need to create packages list\n    local package_list=\"\"\n    for pkg in \"${font_packages[@]}\"; do\n      package_list+=\"                (specification->package \\\"$pkg\\\")\\n\"\n    done\n\n    sed -i \"s|(packages %base-packages)|(packages\\n  (append\\n   (list\\n${package_list}         )\\n   %base-packages))|\" \"$CONFIG_FILE\"\n  else\n    # Already has packages, add fonts\n    for pkg in \"${font_packages[@]}\"; do\n      if ! grep -q \"\\\"$pkg\\\"\" \"$CONFIG_FILE\"; then\n        sed -i \"/specification->package/a\\                (specification->package \\\"$pkg\\\")\" \"$CONFIG_FILE\"\n      fi\n    done\n  fi\n\n  success \"Font packages added to configuration!\"\n  echo \"\"\n  info \"Fonts added:\"\n  info \"  - Fira Code (programming, ligatures)\"\n  info \"  - JetBrains Mono (programming)\"\n  info \"  - DejaVu (general use)\"\n  info \"  - Liberation (MS-compatible)\"\n  info \"  - GNU FreeFont (Unicode coverage)\"\n  info \"  - Font Awesome (icons)\"\n  info \"  - Google Noto (comprehensive)\"\n  echo \"\"\n  info \"After reconfiguring, you may need to rebuild font cache:\"\n  info \"  fc-cache -f -v\"\n  echo \"\"\n  info \"Apply changes with: sudo guix system reconfigure /etc/config.scm\"\n}\n\n# Run if called directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n  add_fonts\nfi\n\n\n---\n\nCONVERSION REQUIREMENTS:\n\n1. Use proper Guile shebang: #!/run/current-system/profile/bin/guile --no-auto-compile -s\n2. Include all necessary use-modules (ice-9 popen, ice-9 rdelim, ice-9 format, srfi srfi-1)\n3. Convert all bash functions to Guile procedures\n4. Use Guile idioms: call-with-input-file, open-input-pipe, etc.\n5. Maintain all functionality from the original script\n6. Add comments explaining complex conversions\n7. Follow naming conventions: predicates end in ?, mutators end in !\n8. Use tail recursion where appropriate\n9. Use GNU coreutils commands (sha256sum not shasum, etc.)\n\nOUTPUT FORMAT:\n\nProvide ONLY the complete converted Guile script. No explanations, no markdown formatting, just the raw .scm file content starting with the shebang.\n"
      }
    ]
  }
}

{
  "custom_id": "convert-postinstall-recipes-add-spacemacs",
  "params": {
    "model": "claude-sonnet-4-5",
    "max_tokens": 8192,
    "messages": [
      {
        "role": "user",
        "content": "Convert this bash script to Guile Scheme following the documentation provided.\n\nREFERENCE DOCUMENTATION:\n\n# GUILE KNOWLEDGE BASE\n\n# Guile Development Knowledge Base\n\n**Purpose**: Central index for Guile Scheme development knowledge in this project.\n\n**Read this before**: Starting any new Guile script or modifying existing .scm files.\n\n---\n\n## Quick Navigation\n\n### ðŸ“š [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md)\nBest practices and design patterns for writing maintainable Guile code.\n\n**Topics:**\n- Module system usage\n- Separation of concerns (REPL/Script/Library)\n- Pure functional style\n- Tail recursion patterns\n- Incremental development\n- Code readability and naming\n- Abstraction levels\n- Performance optimization\n- Scheme conventions\n- Error handling\n\n**Read this**: When designing new functions or refactoring existing code.\n\n---\n\n### âš ï¸  [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md)\nCommon mistakes sorted by frequency (most common first).\n\n**Current top gotchas:**\n1. Missing SRFI-1 import (Count: 3)\n2. Wrong shebang for piped execution (Count: 2)\n3. Using macOS commands on Guix (Count: 2)\n4. Reading only first S-expression (Count: 1)\n5. Wrong invocation for piped scripts (Count: 1)\n\n**Read this**: When you encounter an error, or before writing similar code patterns.\n\n---\n\n## Guile Quick Reference (This Project)\n\n### Standard Shebang for Standalone Scripts\n\n**For regular scripts (executed directly):**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n**For scripts meant to be piped (bootstrap scripts):**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n### Essential Imports\n\n**Minimum for most scripts:**\n```scheme\n(use-modules (ice-9 popen)       ; Command execution\n             (ice-9 rdelim)      ; Line reading\n             (ice-9 format)      ; String formatting\n             (srfi srfi-1))      ; List processing\n```\n\n**For S-expression manipulation:**\n```scheme\n(use-modules (ice-9 pretty-print) ; Pretty-print S-exprs\n             (ice-9 match)        ; Pattern matching\n             (srfi srfi-1))       ; List functions\n```\n\n### Common Patterns\n\n**Reading all S-expressions from a file:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**Executing shell command and capturing output:**\n```scheme\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (values output status)))\n```\n\n**Pattern matching on S-expressions:**\n```scheme\n(use-modules (ice-9 match))\n\n(match expr\n  (('operating-system fields ...)\n   ;; Handle operating-system form\n   ...)\n  (('use-modules modules ...)\n   ;; Handle use-modules form\n   ...)\n  (else\n   ;; Default case\n   ...))\n```\n\n---\n\n## Testing Strategy\n\n### REPL-Driven Development\n\n1. Start Guile REPL: `guile`\n2. Load your module: `(load \"lib/my-script.scm\")`\n3. Test functions interactively\n4. Fix issues and reload\n5. Once working, extract to clean script\n\n### Integration Testing\n\n**For config manipulation:**\n```bash\n# Test with sample config file\nframework-dual/postinstall/tests/run-guile-tests.sh\n```\n\n**For bootstrap scripts:**\n```bash\n# Test in Docker environment\n./test-docker.sh test\n```\n\n---\n\n## File I/O Reference\n\n### Reading Files\n\n```scheme\n;; Read entire file as string\n(call-with-input-file \"path/to/file\" read-string)\n\n;; Read all S-expressions\n(call-with-input-file \"config.scm\"\n  (lambda (port)\n    (let loop ((exprs '()))\n      (let ((expr (read port)))\n        (if (eof-object? expr)\n            (reverse exprs)\n            (loop (cons expr exprs)))))))\n\n;; Read line by line\n(call-with-input-file \"path/to/file\"\n  (lambda (port)\n    (let loop ((lines '()))\n      (let ((line (read-line port)))\n        (if (eof-object? line)\n            (reverse lines)\n            (loop (cons line lines)))))))\n```\n\n### Writing Files\n\n```scheme\n;; Write string to file\n(call-with-output-file \"path/to/file\"\n  (lambda (port)\n    (display \"content\" port)))\n\n;; Pretty-print S-expression to file\n(call-with-output-file \"config.scm\"\n  (lambda (port)\n    (pretty-print expr port)))\n```\n\n---\n\n## Shell Integration\n\n### Running Commands\n\n```scheme\n;; Simple command execution (return status)\n(system \"ls -la\")  ; Returns exit code\n\n;; Execute with proper error handling\n(define (system* cmd)\n  (let ((status (system cmd)))\n    (zero? status)))\n\n;; Capture output\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (if (zero? status)\n        output\n        #f)))\n```\n\n### Platform-Specific Commands\n\n**ALWAYS use GNU coreutils on Guix:**\n- âœ… `sha256sum` (NOT `shasum`)\n- âœ… `md5sum` (NOT `md5`)\n- âœ… `stat` (NOT `gstat`)\n\nSee [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md#count-2-using-macos-commands-on-guix) for details.\n\n---\n\n## When to Use Guile vs Bash\n\n### Use Guile when:\n- Manipulating S-expressions (config.scm files)\n- Complex data transformations\n- Need proper error handling\n- Cross-platform script requirements\n\n### Use Bash when:\n- Simple file operations\n- Gluing together CLI tools\n- Quick one-liners\n- Temporary helper scripts\n\n### Use Guile from Bash:\n```bash\n# Call Guile helper from bash\nguile_add_service() {\n  local module=\"$1\"\n  local service=\"$2\"\n\n  guile --no-auto-compile -s lib/guile-config-helper.scm \\\n    add-service /etc/config.scm \"$module\" \"$service\"\n}\n```\n\n---\n\n## Resources\n\n### Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Learning Resources\n- [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n- [The Guile Hacker's Notebook](https://jeko.frama.io/)\n- [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\n- [System Crafters Community](https://systemcrafters.net/)\n\n### Project-Specific\n- [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md) - Design patterns and coding standards\n- [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md) - Common mistakes (frequency-sorted)\n- [GUILE_CONVERSION.md](GUILE_CONVERSION.md) - Bash-to-Guile conversion strategy\n- [POSTINSTALL_DEV.md](POSTINSTALL_DEV.md) - Postinstall development workflow\n\n---\n\n## Changelog\n\n### 2024-11-15: Major Reorganization\n- Split into three focused files:\n  - GUILE_KNOWLEDGE.md (this file): Quick reference and index\n  - GUILE_BEST_PRACTICES.md: Design patterns and principles\n  - GUILE_GOTCHAS.md: Common mistakes with frequency tracking\n- Streamlined content to be a practical quick reference\n- Added navigation guide and file purposes\n\n### 2024-11-14: Enhanced with Community Resources\n- Added best practice themes (moved to GUILE_BEST_PRACTICES.md)\n- Added recommended learning resources\n- Documented common mistakes (moved to GUILE_GOTCHAS.md)\n\n### 2024-11-14: Initial Creation\n- Documented \"read all S-expressions\" mistake\n- Documented SRFI-1 import requirement\n- Added shebang best practices\n- Added pattern matching guide\n- Added file I/O patterns\n- Added testing strategies\n- Added shell integration patterns\n\n---\n\n# Guile/Scheme Best Practices\n\nBest practices and design patterns for writing maintainable Guile code.\n\nBased on:\n- Community resources (Guile Hacker's Notebook, Wingolog, System Crafters)\n- Functional programming principles\n- Real-world experience from this project\n\nFor common mistakes, see [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md).\n\n---\n\n## Table of Contents\n\n1. [Module System](#1-use-the-module-system-properly)\n2. [Separation of Concerns](#2-separate-concerns-repl-script-library)\n3. [Pure Functional Style](#3-prefer-pure-functional-definitions)\n4. [Tail Recursion](#4-use-tail-calls-and-recursion-carefully)\n5. [Incremental Development](#5-write-tests-and-develop-incrementally)\n6. [Code Readability](#6-code-readability-and-naming)\n7. [Abstraction Levels](#7-use-appropriate-abstraction-levels)\n8. [Performance](#8-mind-performance-when-needed)\n9. [Scheme Conventions](#9-follow-scheme-conventions)\n10. [Error Handling](#10-handle-errors-gracefully)\n\n---\n\n## 1. Use the Module System Properly\n\nStructure code into modules with clear interfaces rather than one giant file:\n\n```scheme\n;; lib/my-module.scm\n(define-module (my-module)\n  #:use-module (ice-9 match)\n  #:use-module (srfi srfi-1)\n  #:export (public-function another-function))\n\n(define (public-function arg)\n  ;; Exported, available to other modules\n  ...)\n\n(define (private-helper arg)\n  ;; Not exported, internal only\n  ...)\n```\n\n**When to use modules:**\n- Reusable code across multiple scripts\n- Clear public/private API boundaries\n- Logical grouping of related functions\n\n**When to use standalone scripts:**\n- Single-purpose tools (like our config helpers)\n- Easier distribution (one file)\n- Simpler for end users\n\n---\n\n## 2. Separate Concerns: REPL, Script, Library\n\n- **Library code**: Pure functions, no I/O, easily testable\n- **Script code**: Thin wrapper that handles I/O and calls library\n- **REPL experimentation**: Interactive development, then extract to library\n\n```scheme\n;; Library: pure logic\n(define (calculate-sum items)\n  (fold + 0 items))\n\n;; Script: I/O wrapper\n(define (main args)\n  (let ((numbers (read-numbers-from-file \"input.txt\")))\n    (display (calculate-sum numbers))))\n```\n\n---\n\n## 3. Prefer Pure Functional Definitions\n\nKeep side-effects isolated (I/O, mutation) so bulk of logic is easy to reason about:\n\n```scheme\n;; Good: pure function\n(define (add-service-to-list services new-service)\n  (if (member new-service services)\n      services\n      (cons new-service services)))\n\n;; Avoid: mutation\n(define (add-service-mutating! services new-service)\n  (set! services (cons new-service services)))  ; Don't do this\n```\n\n**Benefits:**\n- Easier to test (no setup/teardown needed)\n- Easier to reason about (no hidden state)\n- Composable (pure functions combine cleanly)\n- Parallelizable (no shared mutable state)\n\n---\n\n## 4. Use Tail Calls and Recursion Carefully\n\nScheme supports proper tail recursion - use it to avoid stack blow-ups:\n\n```scheme\n;; Good: tail recursive (constant stack)\n(define (sum-list lst)\n  (let loop ((items lst) (acc 0))\n    (if (null? items)\n        acc\n        (loop (cdr items) (+ acc (car items))))))\n\n;; Bad: not tail recursive (grows stack)\n(define (sum-list-bad lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (sum-list-bad (cdr lst)))))\n```\n\n**Common tail-recursive patterns:**\n- Named `let` for loops\n- Accumulator parameter for results\n- Always recurse as last operation\n\n**When recursion is appropriate:**\n- Processing lists or trees\n- State machines\n- Iterative algorithms\n\n**When to use built-in functions instead:**\n- `fold`, `map`, `filter` are already optimized\n- More readable than manual recursion\n- Less error-prone\n\n---\n\n## 5. Write Tests and Develop Incrementally\n\n- Write small modules\n- Test via REPL\n- Build up incrementally\n- Keep examples in comments\n\n```scheme\n;; Example usage in comments:\n;; (add-service '(service foo) '(service bar))\n;; => '(service foo service bar)\n\n(define (add-service services new-service)\n  ...)\n```\n\n**Development workflow:**\n\n1. Start in REPL with small test cases\n2. Extract working code to functions\n3. Add docstrings and examples\n4. Create test files for regression testing\n5. Refactor once tests pass\n\n---\n\n## 6. Code Readability and Naming\n\nScheme has minimal syntax - good naming matters even more:\n\n```scheme\n;; Good: descriptive names\n(define (find-operating-system-expr exprs)\n  (find (lambda (expr)\n          (and (pair? expr)\n               (eq? (car expr) 'operating-system)))\n        exprs))\n\n;; Bad: unclear names\n(define (find-os x)\n  (find (lambda (e) (and (pair? e) (eq? (car e) 'operating-system))) x))\n```\n\n**Naming conventions:**\n- Predicates end in `?`: `empty?`, `file-exists?`\n- Mutators end in `!`: `set!`, `delete-file!`\n- Converters use `->`: `string->number`, `list->vector`\n- Use full words, not abbreviations\n- Be consistent with Scheme stdlib naming\n\n**Formatting:**\n- Indent consistently (2 spaces per level)\n- Align closing parens vertically\n- Break long expressions across lines\n- Group related functions together\n\n---\n\n## 7. Use Appropriate Abstraction Levels\n\nHigher-order functions, closures, macros - use when they improve clarity:\n\n```scheme\n;; Good: clear intent with higher-order function\n(filter (lambda (x) (> x 0)) numbers)\n\n;; Overkill: macro where function suffices\n(define-syntax when-positive  ; Don't do this for simple case\n  (syntax-rules ()\n    ((when-positive x body ...)\n     (if (> x 0) (begin body ...)))))\n```\n\n**Abstraction ladder:**\n\n1. **Direct code**: Simplest, most explicit\n2. **Helper functions**: Reduce duplication\n3. **Higher-order functions**: Parameterize behavior\n4. **Macros**: Create new syntax (use sparingly!)\n\n**When to create abstractions:**\n- Pattern appears 3+ times\n- Logic is complex and benefits from naming\n- Future changes will be localized\n\n**When NOT to abstract:**\n- One-off code\n- Abstraction obscures intent\n- Too early (wait for real duplication)\n\n---\n\n## 8. Mind Performance When Needed\n\n- Use tail recursion to avoid stack growth\n- Avoid quadratic operations (repeated `append`)\n- Consider compilation for frequently-run code\n- Profile before optimizing\n\n```scheme\n;; Slow: O(nÂ²) with repeated append\n(let loop ((items input) (result '()))\n  (if (null? items)\n      result\n      (loop (cdr items) (append result (list (car items))))))\n\n;; Fast: O(n) with cons + reverse\n(reverse\n  (let loop ((items input) (result '()))\n    (if (null? items)\n        result\n        (loop (cdr items) (cons (car items) result)))))\n```\n\n**Common performance pitfalls:**\n- `append` on right side of list (O(n) per call)\n- Deep recursion without tail calls (stack overflow)\n- String concatenation in loops (use `string-append` with list, then join)\n- Repeated `length` calls (cache it if needed)\n\n**Optimization strategy:**\n\n1. Write correct code first\n2. Measure if performance matters\n3. Identify bottlenecks (profiling)\n4. Apply targeted optimizations\n5. Verify correctness still holds\n\n---\n\n## 9. Follow Scheme Conventions\n\nEven with Guile-specific features, stick to Scheme idioms:\n\n**Lexical scope:**\n- Use `let`, `let*`, `letrec` appropriately\n- `let`: bindings don't see each other\n- `let*`: sequential bindings (can reference earlier ones)\n- `letrec`: recursive bindings\n\n**Immutability:**\n- Default to immutable data structures\n- Return new values instead of mutating\n- Use `!` suffix only when truly necessary\n\n**Proper tail calls:**\n- Scheme guarantees tail call optimization\n- Rely on it for iteration\n- No need for explicit loops (unless clearer)\n\n**Closures:**\n- Capture environment for encapsulation\n- Create stateful objects functionally\n- Return functions from functions\n\n---\n\n## 10. Handle Errors Gracefully\n\nProvide helpful error messages with context:\n\n```scheme\n;; Bad: generic error\n(if (not (file-exists? config-file))\n    (error \"File not found\"))\n\n;; Good: specific context\n(if (not (file-exists? config-file))\n    (error (format #f \"Config file not found: ~a\\nExpected at: ~a\"\n                   config-file\n                   (dirname config-file))))\n```\n\n**Error handling strategies:**\n\n**Guard against invalid input:**\n```scheme\n(define (divide a b)\n  (if (zero? b)\n      (error \"Cannot divide by zero\")\n      (/ a b)))\n```\n\n**Validate early:**\n```scheme\n(define (process-config filepath)\n  ;; Validate upfront\n  (unless (file-exists? filepath)\n    (error (format #f \"Config not found: ~a\" filepath)))\n  (unless (access? filepath R_OK)\n    (error (format #f \"Config not readable: ~a\" filepath)))\n\n  ;; Now process\n  ...)\n```\n\n**Provide recovery options:**\n```scheme\n(define (safe-read-config filepath fallback)\n  (if (file-exists? filepath)\n      (call-with-input-file filepath read)\n      fallback))\n```\n\n---\n\n## Resources\n\n### Recommended Learning Resources\n\n#### 1. [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n**The official manual** for Guile, covering how to use it interactively, scripting, modules, debugging, etc.\n\n**Why useful:** Gives you the \"what\" of Guile and how to use the language in practice (not just theory).\n\n**Tip:** Use this as your baseline reference. Whenever you're unsure how to structure a module, script, or use a particular part of the API â€” go here.\n\n#### 2. [The Guile Hacker's Notebook](https://jeko.frama.io/)\nA resource dedicated specifically to Guile: covers concrete programming situations and brings best-practice thinking (TDD, clean code, architecture) into Scheme/Guile.\n\n**Why useful:** Covers how to write maintainable code in Guile, not just syntax.\n\n**Tip:** As you advance from basic syntax into \"how to write maintainable code in Guile\", this is very helpful.\n\n#### 3. [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\nBlog posts and talks by a Guile maintainer. For example: [\"Lessons Learned from Guile, the Ancient & Spry\"](https://wingolog.org/archives/2016/01/11/lessons-learned-from-guile-the-ancient-and-spry)\n\n**Why useful:** Meta-level thinking about how Guile is built and evolves - informs design decisions and best practices.\n\n**Tip:** Use this for understanding \"why\" Guile works the way it does, which helps you make better architecture/style choices.\n\n#### 4. [System Crafters Community Discussions](https://systemcrafters.net/)\nCommunity discussions like \"Is there a good learning material on Guile Scheme?\"\n\n**Why useful:** Honest user reflections - what they found difficult, what worked, common gotchas.\n\n**Tip:** Browse these to see common patterns and pitfalls (especially with modules, REPL, embedding).\n\n### Official Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Quick References\n- Pattern matching: [ice-9 match](https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html)\n- File I/O: [Ports and File Descriptors](https://www.gnu.org/software/guile/manual/html_node/File-Ports.html)\n- Pretty-printing: [ice-9 pretty-print](https://www.gnu.org/software/guile/manual/html_node/Pretty_002dPrinting.html)\n- Tail calls: [Expressions](https://www.gnu.org/software/guile/manual/html_node/Expressions.html)\n- Modules: [Modules](https://www.gnu.org/software/guile/manual/html_node/Modules.html)\n\n### Performance and Optimization\n- [David Thompson: Optimizing Guile](https://dthompson.us/posts/optimize-guile.html)\n- Guile compilation, bytecode, and performance considerations\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted best practices from GUILE_KNOWLEDGE.md\n- Organized into 10 thematic sections\n- Added practical examples for each principle\n- Included learning resources and references\n\n---\n\n# Guile/Scheme Gotchas and Common Mistakes\n\nThis document tracks mistakes we've actually made during development, sorted by frequency.\n\n**Format**: Each gotcha includes:\n- **Count**: Number of times we've hit this issue (kept up-to-date)\n- **The Mistake**: What we did wrong\n- **Why It Failed**: Technical explanation\n- **The Fix**: Correct approach\n- **When to Watch For**: Situations where this mistake is likely\n\n---\n\n## Gotcha Leaderboard (Sorted by Frequency)\n\n### [Count: 3] Missing SRFI-1 Import\n\n**The Mistake:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match))\n\n;; Later in code:\n(let ((filtered (filter-map some-fn items)))  ; ERROR!\n  ...)\n```\n\n**Why It Failed:**\n```\nERROR: Unbound variable: filter-map\n```\n\nList processing functions like `filter-map`, `fold`, `take`, `take-right`, etc. are not part of core Guile - they come from SRFI-1.\n\n**The Fix:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (srfi srfi-1))  ; REQUIRED for list functions\n```\n\n**When to Watch For:**\n- Using any list function beyond basic `car`, `cdr`, `cons`, `append`\n- Processing collections with `filter-map`, `fold`, `partition`\n- Taking slices with `take`, `drop`, `take-right`, `drop-right`\n\n**Frequency Notes:**\n- 2024-11-14: Initial occurrence (guile-config-helper.scm)\n- 2024-11-14: bootstrap-postinstall.scm (take/take-right)\n- 2024-11-15: Future occurrence tracking starts here\n\n---\n\n### [Count: 2] Wrong Shebang for Piped Execution\n\n**The Mistake:**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\nWhen piped: `curl ... | guile`\n\n**Why It Failed:**\n```\n;;; In procedure primitive-load:\n;;; No such file or directory: \"/home/durant/-\"\n```\n\nThe `-s` flag tells Guile to expect a script filename argument. When piped, leftover `-` from arguments gets interpreted as a file path.\n\n**The Fix:**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n**When to Watch For:**\n- Creating scripts meant to be piped via curl\n- Scripts that should read from stdin\n- Bootstrap/installer scripts\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm initial shebang\n- 2024-11-15: Fixed by removing -s flag\n\n---\n\n### [Count: 2] Using macOS Commands on Guix\n\n**The Mistake:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"shasum -a 256 ~s\" filepath)))\n         ...))\n```\n\n**Why It Failed:**\n```\n/gnu/store/.../bash: line 1: shasum: command not found\n```\n\n`shasum` is a BSD/macOS tool. Guix systems use GNU coreutils which provides `sha256sum`.\n\n**The Fix:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"sha256sum ~s\" filepath)))\n         ...))\n```\n\n**When to Watch For:**\n- Porting scripts from macOS development to Guix deployment\n- Using BSD-specific commands: `shasum`, `md5`, `gstat`, etc.\n- Always use GNU coreutils equivalents: `sha256sum`, `md5sum`, `stat`\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm checksum function\n- 2024-11-15: Will likely happen again when porting more scripts\n\n---\n\n### [Count: 1] Reading Only First S-expression\n\n**The Mistake:**\n```scheme\n(define (read-config filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (read port))))  ; ONLY READS FIRST FORM!\n```\n\n**Why It Failed:**\nGuix config files have multiple top-level S-expressions:\n```scheme\n(use-modules (gnu))  ; First form\n(use-modules (gnu services networking))  ; Second form\n(operating-system ...)  ; Third form\n```\n\nOnly got `(use-modules (gnu))`, missing the rest!\n\n**The Fix:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**When to Watch For:**\n- Reading Guix config files (always have multiple use-modules + operating-system)\n- Processing Scheme files with multiple top-level definitions\n- Any file that's more than a single S-expression\n\n**Frequency Notes:**\n- 2024-11-14: guile-config-helper.scm initial implementation\n\n---\n\n### [Count: 1] Wrong Invocation for Piped Scripts\n\n**The Mistake:**\n```bash\ncurl ... | guile --no-auto-compile -s -\n```\n\n**Why It Failed:**\nThe `-s -` combination causes Guile to look for a script file named `-`, leading to path resolution errors.\n\n**The Fix:**\n```bash\ncurl ... | guile\n```\n\nWith the correct shebang (backslash continuation, no `-s`), Guile reads from stdin automatically.\n\n**When to Watch For:**\n- One-liner bootstrap commands\n- Documentation examples for piped execution\n- CI/CD scripts that download and run Guile code\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm documentation\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted gotchas from GUILE_KNOWLEDGE.md\n- Established frequency tracking system\n- Sorted by count (highest first)\n- Added 5 initial gotchas with counts\n\n### Frequency Tracking Protocol\n\nWhen you encounter a gotcha:\n\n1. **If it's already listed**: Increment the count, add date note\n2. **If it's new**: Add it with `[Count: 1]`, insert in sorted position\n3. **Periodically re-sort**: Keep highest-frequency gotchas at top\n4. **Update notes**: Add specific occurrence details to help identify patterns\n\nThis ensures the most common mistakes are always visible first!\n\n---\n\n# Guile Conversion Plan\n\n## Overview\n\nWe're systematically converting all shell scripts that run on Guix systems to Guile Scheme. This provides:\n\n- **Proper S-expression handling** for config.scm manipulation\n- **Type safety** and better error handling\n- **Consistency** with Guix's native language\n- **Maintainability** through structured code\n- **Future-proofing** for advanced Guix features\n\n## Conversion Strategy\n\n### Phase 1: Library Infrastructure (COMPLETED)\n- âœ… Created `lib/guile-config-helper.scm` for S-expression manipulation\n- âœ… Set up Guile testing in Docker\n- âœ… Created test framework in `lib/tests/`\n- âœ… Verified Guile integration with existing Go/shell tests\n\n### Phase 2: Postinstall Scripts (IN PROGRESS)\nConvert postinstall customization scripts to use Guile helper:\n\n1. Update `framework-dual/postinstall/customize` to use Guile helper\n2. Create similar for other platforms\n3. Test GNOME, NetworkManager, SSH configurations\n\n### Phase 3: Critical Installation Scripts (PLANNED)\nConvert lib/*.sh scripts to Guile:\n\nPriority order (by complexity and criticality):\n\n1. **lib/postinstall.sh** (744B) - Simplest, good starting point\n   - Channel generation utilities\n   - Used by customize scripts\n\n2. **lib/clean-install.sh** (3.0K) - Medium complexity\n   - Clean installation wrapper\n   - Calls into Go installer\n\n3. **lib/verify-guix-install.sh** (8.2K) - Complex verification\n   - Post-install verification\n   - System checks\n\n4. **lib/bootstrap-installer.sh** (7.6K) - Bootstrap logic\n   - Downloads and verifies repo\n   - Builds Go installer\n\n5. **lib/recovery-complete-install.sh** (13K) - Most complex\n   - Recovery scenarios\n   - Multiple installation paths\n\n6. **lib/channel-utils.sh** (6.8K) - Channel management\n   - Mirror selection\n   - Channel configuration\n\n### Phase 4: Integration and Testing\n- Update all platform READMEs\n- Create comprehensive Guile test suite\n- Docker testing for all conversions\n- Update documentation\n\n## Conversion Guidelines\n\n### Shebang for Guile Scripts on Guix\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n### Module Structure\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (ice-9 rdelim)\n             (srfi srfi-1)\n             (srfi srfi-26))  ; cut/cute for partial application\n```\n\n### Common Patterns\n\n#### Bash â†’ Guile\n\n**Command execution:**\n```bash\n# Bash\noutput=$(command arg1 arg2)\nif [ $? -eq 0 ]; then\n    echo \"Success\"\nfi\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 popen) (ice-9 rdelim))\n\n(let* ((port (open-input-pipe \"command arg1 arg2\"))\n       (output (read-string port))\n       (status (close-pipe port)))\n  (if (zero? status)\n      (display \"Success\\n\")))\n```\n\n**File operations:**\n```bash\n# Bash\nif [ -f \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n```\n\n```scheme\n;; Guile\n(when (file-exists? file)\n  (let ((content (call-with-input-file file read-string)))\n    ...))\n```\n\n**Argument parsing:**\n```bash\n# Bash\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --flag) FLAG=true; shift ;;\n        *) ARG=$1; shift ;;\n    esac\ndone\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 getopt-long))\n\n(define option-spec\n  '((flag (single-char #\\f) (value #f))\n    (arg (single-char #\\a) (value #t))))\n\n(let ((options (getopt-long (command-line) option-spec)))\n  (define flag (option-ref options 'flag #f))\n  (define arg (option-ref options 'arg #f))\n  ...)\n```\n\n## Testing Requirements\n\nEach converted script must have:\n\n1. **Unit tests** in `lib/tests/test-<script-name>.scm`\n2. **Integration tests** verifying behavior matches bash version\n3. **Docker tests** ensuring Guile dependencies are available\n4. **Documentation** explaining any behavior changes\n\n## Status Tracking\n\n| Script | Lines | Status | Tests | Notes |\n|--------|-------|--------|-------|-------|\n| guile-config-helper.scm | 169 | âœ… Done | âœ… Passing | S-expression manipulation |\n| postinstall.sh | 31 | ðŸ”„ Next | â¸ï¸ Pending | Channel utilities |\n| clean-install.sh | 134 | â¸ï¸ Planned | â¸ï¸ Pending | Installation wrapper |\n| verify-guix-install.sh | 305 | â¸ï¸ Planned | â¸ï¸ Pending | Verification checks |\n| bootstrap-installer.sh | 267 | â¸ï¸ Planned | â¸ï¸ Pending | Bootstrap logic |\n| recovery-complete-install.sh | 458 | â¸ï¸ Planned | â¸ï¸ Pending | Recovery flows |\n| channel-utils.sh | 235 | â¸ï¸ Planned | â¸ï¸ Pending | Channel/mirror selection |\n\n## Migration Path\n\nFor each script:\n\n1. **Analyze** - Understand current bash implementation\n2. **Design** - Plan Guile equivalent with better structure\n3. **Implement** - Write .scm version alongside .sh\n4. **Test** - Comprehensive testing in Docker + real Guix\n5. **Document** - Update all references and docs\n6. **Deploy** - Switch references from .sh to .scm\n7. **Deprecate** - Mark .sh as deprecated\n8. **Remove** - Delete .sh after stable period\n\n## Notes\n\n- **Coexistence**: .sh and .scm versions will coexist during transition\n- **Testing**: Both versions tested until .scm proven stable\n- **Rollback**: Keep .sh versions until all platforms verified\n- **Knowledge Base**: See [GUILE_KNOWLEDGE.md](GUILE_KNOWLEDGE.md) for lessons learned and best practices\n- **Read First**: Review GUILE_KNOWLEDGE.md before starting any Guile development work\n\n\n---\n\nORIGINAL SCRIPT PATH: postinstall/recipes/add-spacemacs.sh\n\nORIGINAL SCRIPT CONTENT:\n\n#!/usr/bin/env bash\n# Shared recipe: Install and configure Spacemacs\n# Can be called from any platform's customize tool\n\nset -euo pipefail\n\nCONFIG_FILE=\"${CONFIG_FILE:-/etc/config.scm}\"\n\n# Colors\ninfo() { printf \"  %s\\n\" \"$*\"; }\nwarn() { printf \"\\n\\033[1;33m[warn]\\033[0m %s\\n\" \"$*\"; }\nsuccess() { printf \"\\n\\033[1;32m[âœ“]\\033[0m %s\\n\" \"$*\"; }\n\nadd_spacemacs() {\n  echo \"\"\n  echo \"=== Installing Spacemacs ===\"\n  echo \"\"\n\n  # Check if Emacs is already installed\n  if ! grep -q \"emacs\" \"$CONFIG_FILE\"; then\n    info \"Adding Emacs package to config.scm...\"\n\n    # Add use-package-modules declaration if not present\n    if ! grep -q \"(use-package-modules\" \"$CONFIG_FILE\"; then\n      # Add after use-modules line\n      sed -i '/(use-modules/a\\             (gnu packages emacs)\\n             (gnu packages version-control))' \"$CONFIG_FILE\"\n    else\n      # Add to existing use-package-modules if emacs not there\n      if ! grep -q \"gnu packages emacs\" \"$CONFIG_FILE\"; then\n        sed -i '/(use-modules/a\\             (gnu packages emacs)\\n             (gnu packages version-control))' \"$CONFIG_FILE\"\n      fi\n    fi\n\n    # Add emacs to packages\n    if grep -q \"(packages %base-packages)\" \"$CONFIG_FILE\"; then\n      # Minimal config - expand to use append\n      sed -i 's|(packages %base-packages)|(packages\\n  (append\\n   (list emacs\\n         git)\\n   %base-packages))|' \"$CONFIG_FILE\"\n    else\n      # Already has packages list, add emacs to it\n      sed -i '/(packages/,/))/ { /list/ { s/list/list emacs\\n         git/ } }' \"$CONFIG_FILE\"\n    fi\n\n    info \"Emacs added to configuration\"\n  else\n    info \"Emacs already in configuration\"\n  fi\n\n  # Ask if user wants to import existing config\n  echo \"\"\n  read -r -p \"Do you have an existing Spacemacs config (.spacemacs) to import? [y/N] \" import_config </dev/tty\n\n  if [[ \"$import_config\" =~ ^[Yy]$ ]]; then\n    echo \"\"\n    info \"Import options:\"\n    info \"  1. Git repository URL (for .spacemacs file)\"\n    info \"  2. Skip import (install fresh, import manually later)\"\n    echo \"\"\n    read -r -p \"Enter choice [1-2]: \" choice </dev/tty\n\n    case \"$choice\" in\n      1)\n        read -r -p \"Enter Git repository URL (e.g., https://github.com/user/dotfiles): \" repo_url </dev/tty\n        read -r -p \"Path to .spacemacs in repo (e.g., .spacemacs or emacs/.spacemacs): \" spacemacs_path </dev/tty\n        if [[ -n \"$repo_url\" ]]; then\n          info \"Will import .spacemacs from: $repo_url\"\n          IMPORT_SPACEMACS_REPO=\"$repo_url\"\n          IMPORT_SPACEMACS_PATH=\"${spacemacs_path:-.spacemacs}\"\n        else\n          warn \"No URL provided, will create default config\"\n        fi\n        ;;\n      2)\n        info \"Skipping import - you can manually import later\"\n        info \"See: ~/guix-customize/EMACS_IMPORT_GUIDE.md\"\n        ;;\n      *)\n        warn \"Invalid choice, will create default config\"\n        ;;\n    esac\n  fi\n\n  # Install Spacemacs\n  info \"Installing Spacemacs to ~/.emacs.d...\"\n\n  if [[ -d \"$HOME/.emacs.d\" ]]; then\n    warn \"~/.emacs.d already exists\"\n    read -r -p \"Backup and replace with Spacemacs? [y/N] \" ans </dev/tty\n    if [[ \"$ans\" =~ ^[Yy]$ ]]; then\n      mv \"$HOME/.emacs.d\" \"$HOME/.emacs.d.backup.$(date +%Y%m%d-%H%M%S)\"\n      info \"Backed up existing .emacs.d\"\n    else\n      info \"Skipping Spacemacs installation\"\n      return 0\n    fi\n  fi\n\n  git clone https://github.com/syl20bnr/spacemacs \"$HOME/.emacs.d\"\n\n  # Import user's .spacemacs or create default\n  if [[ -n \"$IMPORT_SPACEMACS_REPO\" ]]; then\n    info \"Importing your .spacemacs from repository...\"\n    if git clone \"$IMPORT_SPACEMACS_REPO\" \"$HOME/.spacemacs-tmp\"; then\n      if [[ -f \"$HOME/.spacemacs-tmp/$IMPORT_SPACEMACS_PATH\" ]]; then\n        cp \"$HOME/.spacemacs-tmp/$IMPORT_SPACEMACS_PATH\" \"$HOME/.spacemacs\"\n        rm -rf \"$HOME/.spacemacs-tmp\"\n        success \".spacemacs imported successfully!\"\n      else\n        warn \"Could not find $IMPORT_SPACEMACS_PATH in repository\"\n        rm -rf \"$HOME/.spacemacs-tmp\"\n        IMPORT_SPACEMACS_REPO=\"\"\n      fi\n    else\n      warn \"Failed to clone repository, creating default config instead\"\n      IMPORT_SPACEMACS_REPO=\"\"\n    fi\n  fi\n\n  # Create basic .spacemacs configuration if not imported\n  if [[ -z \"$IMPORT_SPACEMACS_REPO\" ]] && [[ ! -f \"$HOME/.spacemacs\" ]]; then\n    info \"Creating basic .spacemacs configuration...\"\n    cat > \"$HOME/.spacemacs\" <<'EOF'\n;; -*- mode: emacs-lisp; lexical-binding: t -*-\n;; Basic Spacemacs configuration\n\n(defun dotspacemacs/layers ()\n  (setq-default\n   dotspacemacs-distribution 'spacemacs\n   dotspacemacs-enable-lazy-installation 'unused\n   dotspacemacs-ask-for-lazy-installation t\n   dotspacemacs-configuration-layer-path '()\n\n   dotspacemacs-configuration-layers\n   '(\n     ;; Add your layers here\n     helm\n     auto-completion\n     better-defaults\n     emacs-lisp\n     git\n     markdown\n     org\n     (shell :variables\n            shell-default-height 30\n            shell-default-position 'bottom)\n     syntax-checking\n     version-control\n     )\n\n   dotspacemacs-additional-packages '()\n   dotspacemacs-frozen-packages '()\n   dotspacemacs-excluded-packages '()\n   dotspacemacs-install-packages 'used-only))\n\n(defun dotspacemacs/init ()\n  (setq-default\n   dotspacemacs-elpa-https t\n   dotspacemacs-elpa-timeout 5\n   dotspacemacs-check-for-update nil\n   dotspacemacs-elpa-subdirectory nil\n   dotspacemacs-editing-style 'vim\n   dotspacemacs-verbose-loading nil\n   dotspacemacs-startup-banner 'official\n   dotspacemacs-startup-lists '((recents . 5)\n                                 (projects . 7))\n   dotspacemacs-themes '(spacemacs-dark\n                          spacemacs-light)\n   dotspacemacs-colorize-cursor-according-to-state t\n   dotspacemacs-default-font '(\"Source Code Pro\"\n                                :size 13\n                                :weight normal\n                                :width normal)\n   dotspacemacs-leader-key \"SPC\"\n   dotspacemacs-emacs-command-key \"SPC\"\n   dotspacemacs-ex-command-key \":\"\n   dotspacemacs-emacs-leader-key \"M-m\"\n   dotspacemacs-major-mode-leader-key \",\"\n   dotspacemacs-major-mode-emacs-leader-key \"C-M-m\"\n   dotspacemacs-distinguish-gui-tab nil\n   dotspacemacs-remap-Y-to-y$ nil\n   dotspacemacs-retain-visual-state-on-shift t\n   dotspacemacs-visual-line-move-text nil\n   dotspacemacs-ex-substitute-global nil\n   dotspacemacs-default-layout-name \"Default\"\n   dotspacemacs-display-default-layout nil\n   dotspacemacs-auto-resume-layouts nil\n   dotspacemacs-large-file-size 1\n   dotspacemacs-auto-save-file-location 'cache\n   dotspacemacs-max-rollback-slots 5\n   dotspacemacs-helm-resize nil\n   dotspacemacs-helm-no-header nil\n   dotspacemacs-helm-position 'bottom\n   dotspacemacs-helm-use-fuzzy 'always\n   dotspacemacs-enable-paste-transient-state nil\n   dotspacemacs-which-key-delay 0.4\n   dotspacemacs-which-key-position 'bottom\n   dotspacemacs-loading-progress-bar t\n   dotspacemacs-fullscreen-at-startup nil\n   dotspacemacs-fullscreen-use-non-native nil\n   dotspacemacs-maximized-at-startup nil\n   dotspacemacs-active-transparency 90\n   dotspacemacs-inactive-transparency 90\n   dotspacemacs-show-transient-state-title t\n   dotspacemacs-show-transient-state-color-guide t\n   dotspacemacs-mode-line-unicode-symbols t\n   dotspacemacs-smooth-scrolling t\n   dotspacemacs-line-numbers nil\n   dotspacemacs-folding-method 'evil\n   dotspacemacs-smartparens-strict-mode nil\n   dotspacemacs-smart-closing-parenthesis nil\n   dotspacemacs-highlight-delimiters 'all\n   dotspacemacs-persistent-server nil\n   dotspacemacs-search-tools '(\"ag\" \"pt\" \"ack\" \"grep\")\n   dotspacemacs-default-package-repository nil\n   dotspacemacs-whitespace-cleanup nil\n   ))\n\n(defun dotspacemacs/user-init ()\n  \"Initialization function for user code.\")\n\n(defun dotspacemacs/user-config ()\n  \"Configuration function for user code.\")\n\n;; Do not write anything past this comment.\nEOF\n    success \"Created .spacemacs configuration\"\n  else\n    info \".spacemacs already exists, keeping your configuration\"\n  fi\n\n  success \"Spacemacs installation complete!\"\n  echo \"\"\n  info \"Next steps:\"\n  info \"  1. Apply config: sudo guix system reconfigure /etc/config.scm\"\n  info \"  2. Launch Emacs to complete Spacemacs setup\"\n  if [[ -z \"$IMPORT_SPACEMACS_REPO\" ]]; then\n    info \"  3. First launch will download and install packages (may take a while)\"\n  else\n    info \"  3. Imported config will install its packages on first launch\"\n  fi\n  echo \"\"\n  info \"Spacemacs quick start:\"\n  info \"  SPC f f - Find file\"\n  info \"  SPC p f - Find file in project\"\n  info \"  SPC b b - Switch buffer\"\n  info \"  SPC w / - Split window vertically\"\n  info \"  SPC w - - Split window horizontally\"\n  info \"  SPC q q - Quit\"\n  echo \"\"\n  if [[ -z \"$IMPORT_SPACEMACS_REPO\" ]]; then\n    info \"To import your config later, see: ~/guix-customize/EMACS_IMPORT_GUIDE.md\"\n  fi\n  echo \"\"\n}\n\n# Run if called directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n  add_spacemacs\nfi\n\n\n---\n\nCONVERSION REQUIREMENTS:\n\n1. Use proper Guile shebang: #!/run/current-system/profile/bin/guile --no-auto-compile -s\n2. Include all necessary use-modules (ice-9 popen, ice-9 rdelim, ice-9 format, srfi srfi-1)\n3. Convert all bash functions to Guile procedures\n4. Use Guile idioms: call-with-input-file, open-input-pipe, etc.\n5. Maintain all functionality from the original script\n6. Add comments explaining complex conversions\n7. Follow naming conventions: predicates end in ?, mutators end in !\n8. Use tail recursion where appropriate\n9. Use GNU coreutils commands (sha256sum not shasum, etc.)\n\nOUTPUT FORMAT:\n\nProvide ONLY the complete converted Guile script. No explanations, no markdown formatting, just the raw .scm file content starting with the shebang.\n"
      }
    ]
  }
}

{
  "custom_id": "convert-postinstall-recipes-add-vanilla-emacs",
  "params": {
    "model": "claude-sonnet-4-5",
    "max_tokens": 8192,
    "messages": [
      {
        "role": "user",
        "content": "Convert this bash script to Guile Scheme following the documentation provided.\n\nREFERENCE DOCUMENTATION:\n\n# GUILE KNOWLEDGE BASE\n\n# Guile Development Knowledge Base\n\n**Purpose**: Central index for Guile Scheme development knowledge in this project.\n\n**Read this before**: Starting any new Guile script or modifying existing .scm files.\n\n---\n\n## Quick Navigation\n\n### ðŸ“š [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md)\nBest practices and design patterns for writing maintainable Guile code.\n\n**Topics:**\n- Module system usage\n- Separation of concerns (REPL/Script/Library)\n- Pure functional style\n- Tail recursion patterns\n- Incremental development\n- Code readability and naming\n- Abstraction levels\n- Performance optimization\n- Scheme conventions\n- Error handling\n\n**Read this**: When designing new functions or refactoring existing code.\n\n---\n\n### âš ï¸  [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md)\nCommon mistakes sorted by frequency (most common first).\n\n**Current top gotchas:**\n1. Missing SRFI-1 import (Count: 3)\n2. Wrong shebang for piped execution (Count: 2)\n3. Using macOS commands on Guix (Count: 2)\n4. Reading only first S-expression (Count: 1)\n5. Wrong invocation for piped scripts (Count: 1)\n\n**Read this**: When you encounter an error, or before writing similar code patterns.\n\n---\n\n## Guile Quick Reference (This Project)\n\n### Standard Shebang for Standalone Scripts\n\n**For regular scripts (executed directly):**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n**For scripts meant to be piped (bootstrap scripts):**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n### Essential Imports\n\n**Minimum for most scripts:**\n```scheme\n(use-modules (ice-9 popen)       ; Command execution\n             (ice-9 rdelim)      ; Line reading\n             (ice-9 format)      ; String formatting\n             (srfi srfi-1))      ; List processing\n```\n\n**For S-expression manipulation:**\n```scheme\n(use-modules (ice-9 pretty-print) ; Pretty-print S-exprs\n             (ice-9 match)        ; Pattern matching\n             (srfi srfi-1))       ; List functions\n```\n\n### Common Patterns\n\n**Reading all S-expressions from a file:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**Executing shell command and capturing output:**\n```scheme\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (values output status)))\n```\n\n**Pattern matching on S-expressions:**\n```scheme\n(use-modules (ice-9 match))\n\n(match expr\n  (('operating-system fields ...)\n   ;; Handle operating-system form\n   ...)\n  (('use-modules modules ...)\n   ;; Handle use-modules form\n   ...)\n  (else\n   ;; Default case\n   ...))\n```\n\n---\n\n## Testing Strategy\n\n### REPL-Driven Development\n\n1. Start Guile REPL: `guile`\n2. Load your module: `(load \"lib/my-script.scm\")`\n3. Test functions interactively\n4. Fix issues and reload\n5. Once working, extract to clean script\n\n### Integration Testing\n\n**For config manipulation:**\n```bash\n# Test with sample config file\nframework-dual/postinstall/tests/run-guile-tests.sh\n```\n\n**For bootstrap scripts:**\n```bash\n# Test in Docker environment\n./test-docker.sh test\n```\n\n---\n\n## File I/O Reference\n\n### Reading Files\n\n```scheme\n;; Read entire file as string\n(call-with-input-file \"path/to/file\" read-string)\n\n;; Read all S-expressions\n(call-with-input-file \"config.scm\"\n  (lambda (port)\n    (let loop ((exprs '()))\n      (let ((expr (read port)))\n        (if (eof-object? expr)\n            (reverse exprs)\n            (loop (cons expr exprs)))))))\n\n;; Read line by line\n(call-with-input-file \"path/to/file\"\n  (lambda (port)\n    (let loop ((lines '()))\n      (let ((line (read-line port)))\n        (if (eof-object? line)\n            (reverse lines)\n            (loop (cons line lines)))))))\n```\n\n### Writing Files\n\n```scheme\n;; Write string to file\n(call-with-output-file \"path/to/file\"\n  (lambda (port)\n    (display \"content\" port)))\n\n;; Pretty-print S-expression to file\n(call-with-output-file \"config.scm\"\n  (lambda (port)\n    (pretty-print expr port)))\n```\n\n---\n\n## Shell Integration\n\n### Running Commands\n\n```scheme\n;; Simple command execution (return status)\n(system \"ls -la\")  ; Returns exit code\n\n;; Execute with proper error handling\n(define (system* cmd)\n  (let ((status (system cmd)))\n    (zero? status)))\n\n;; Capture output\n(define (run-command cmd)\n  (let* ((port (open-input-pipe cmd))\n         (output (read-string port))\n         (status (close-pipe port)))\n    (if (zero? status)\n        output\n        #f)))\n```\n\n### Platform-Specific Commands\n\n**ALWAYS use GNU coreutils on Guix:**\n- âœ… `sha256sum` (NOT `shasum`)\n- âœ… `md5sum` (NOT `md5`)\n- âœ… `stat` (NOT `gstat`)\n\nSee [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md#count-2-using-macos-commands-on-guix) for details.\n\n---\n\n## When to Use Guile vs Bash\n\n### Use Guile when:\n- Manipulating S-expressions (config.scm files)\n- Complex data transformations\n- Need proper error handling\n- Cross-platform script requirements\n\n### Use Bash when:\n- Simple file operations\n- Gluing together CLI tools\n- Quick one-liners\n- Temporary helper scripts\n\n### Use Guile from Bash:\n```bash\n# Call Guile helper from bash\nguile_add_service() {\n  local module=\"$1\"\n  local service=\"$2\"\n\n  guile --no-auto-compile -s lib/guile-config-helper.scm \\\n    add-service /etc/config.scm \"$module\" \"$service\"\n}\n```\n\n---\n\n## Resources\n\n### Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Learning Resources\n- [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n- [The Guile Hacker's Notebook](https://jeko.frama.io/)\n- [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\n- [System Crafters Community](https://systemcrafters.net/)\n\n### Project-Specific\n- [GUILE_BEST_PRACTICES.md](GUILE_BEST_PRACTICES.md) - Design patterns and coding standards\n- [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md) - Common mistakes (frequency-sorted)\n- [GUILE_CONVERSION.md](GUILE_CONVERSION.md) - Bash-to-Guile conversion strategy\n- [POSTINSTALL_DEV.md](POSTINSTALL_DEV.md) - Postinstall development workflow\n\n---\n\n## Changelog\n\n### 2024-11-15: Major Reorganization\n- Split into three focused files:\n  - GUILE_KNOWLEDGE.md (this file): Quick reference and index\n  - GUILE_BEST_PRACTICES.md: Design patterns and principles\n  - GUILE_GOTCHAS.md: Common mistakes with frequency tracking\n- Streamlined content to be a practical quick reference\n- Added navigation guide and file purposes\n\n### 2024-11-14: Enhanced with Community Resources\n- Added best practice themes (moved to GUILE_BEST_PRACTICES.md)\n- Added recommended learning resources\n- Documented common mistakes (moved to GUILE_GOTCHAS.md)\n\n### 2024-11-14: Initial Creation\n- Documented \"read all S-expressions\" mistake\n- Documented SRFI-1 import requirement\n- Added shebang best practices\n- Added pattern matching guide\n- Added file I/O patterns\n- Added testing strategies\n- Added shell integration patterns\n\n---\n\n# Guile/Scheme Best Practices\n\nBest practices and design patterns for writing maintainable Guile code.\n\nBased on:\n- Community resources (Guile Hacker's Notebook, Wingolog, System Crafters)\n- Functional programming principles\n- Real-world experience from this project\n\nFor common mistakes, see [GUILE_GOTCHAS.md](GUILE_GOTCHAS.md).\n\n---\n\n## Table of Contents\n\n1. [Module System](#1-use-the-module-system-properly)\n2. [Separation of Concerns](#2-separate-concerns-repl-script-library)\n3. [Pure Functional Style](#3-prefer-pure-functional-definitions)\n4. [Tail Recursion](#4-use-tail-calls-and-recursion-carefully)\n5. [Incremental Development](#5-write-tests-and-develop-incrementally)\n6. [Code Readability](#6-code-readability-and-naming)\n7. [Abstraction Levels](#7-use-appropriate-abstraction-levels)\n8. [Performance](#8-mind-performance-when-needed)\n9. [Scheme Conventions](#9-follow-scheme-conventions)\n10. [Error Handling](#10-handle-errors-gracefully)\n\n---\n\n## 1. Use the Module System Properly\n\nStructure code into modules with clear interfaces rather than one giant file:\n\n```scheme\n;; lib/my-module.scm\n(define-module (my-module)\n  #:use-module (ice-9 match)\n  #:use-module (srfi srfi-1)\n  #:export (public-function another-function))\n\n(define (public-function arg)\n  ;; Exported, available to other modules\n  ...)\n\n(define (private-helper arg)\n  ;; Not exported, internal only\n  ...)\n```\n\n**When to use modules:**\n- Reusable code across multiple scripts\n- Clear public/private API boundaries\n- Logical grouping of related functions\n\n**When to use standalone scripts:**\n- Single-purpose tools (like our config helpers)\n- Easier distribution (one file)\n- Simpler for end users\n\n---\n\n## 2. Separate Concerns: REPL, Script, Library\n\n- **Library code**: Pure functions, no I/O, easily testable\n- **Script code**: Thin wrapper that handles I/O and calls library\n- **REPL experimentation**: Interactive development, then extract to library\n\n```scheme\n;; Library: pure logic\n(define (calculate-sum items)\n  (fold + 0 items))\n\n;; Script: I/O wrapper\n(define (main args)\n  (let ((numbers (read-numbers-from-file \"input.txt\")))\n    (display (calculate-sum numbers))))\n```\n\n---\n\n## 3. Prefer Pure Functional Definitions\n\nKeep side-effects isolated (I/O, mutation) so bulk of logic is easy to reason about:\n\n```scheme\n;; Good: pure function\n(define (add-service-to-list services new-service)\n  (if (member new-service services)\n      services\n      (cons new-service services)))\n\n;; Avoid: mutation\n(define (add-service-mutating! services new-service)\n  (set! services (cons new-service services)))  ; Don't do this\n```\n\n**Benefits:**\n- Easier to test (no setup/teardown needed)\n- Easier to reason about (no hidden state)\n- Composable (pure functions combine cleanly)\n- Parallelizable (no shared mutable state)\n\n---\n\n## 4. Use Tail Calls and Recursion Carefully\n\nScheme supports proper tail recursion - use it to avoid stack blow-ups:\n\n```scheme\n;; Good: tail recursive (constant stack)\n(define (sum-list lst)\n  (let loop ((items lst) (acc 0))\n    (if (null? items)\n        acc\n        (loop (cdr items) (+ acc (car items))))))\n\n;; Bad: not tail recursive (grows stack)\n(define (sum-list-bad lst)\n  (if (null? lst)\n      0\n      (+ (car lst) (sum-list-bad (cdr lst)))))\n```\n\n**Common tail-recursive patterns:**\n- Named `let` for loops\n- Accumulator parameter for results\n- Always recurse as last operation\n\n**When recursion is appropriate:**\n- Processing lists or trees\n- State machines\n- Iterative algorithms\n\n**When to use built-in functions instead:**\n- `fold`, `map`, `filter` are already optimized\n- More readable than manual recursion\n- Less error-prone\n\n---\n\n## 5. Write Tests and Develop Incrementally\n\n- Write small modules\n- Test via REPL\n- Build up incrementally\n- Keep examples in comments\n\n```scheme\n;; Example usage in comments:\n;; (add-service '(service foo) '(service bar))\n;; => '(service foo service bar)\n\n(define (add-service services new-service)\n  ...)\n```\n\n**Development workflow:**\n\n1. Start in REPL with small test cases\n2. Extract working code to functions\n3. Add docstrings and examples\n4. Create test files for regression testing\n5. Refactor once tests pass\n\n---\n\n## 6. Code Readability and Naming\n\nScheme has minimal syntax - good naming matters even more:\n\n```scheme\n;; Good: descriptive names\n(define (find-operating-system-expr exprs)\n  (find (lambda (expr)\n          (and (pair? expr)\n               (eq? (car expr) 'operating-system)))\n        exprs))\n\n;; Bad: unclear names\n(define (find-os x)\n  (find (lambda (e) (and (pair? e) (eq? (car e) 'operating-system))) x))\n```\n\n**Naming conventions:**\n- Predicates end in `?`: `empty?`, `file-exists?`\n- Mutators end in `!`: `set!`, `delete-file!`\n- Converters use `->`: `string->number`, `list->vector`\n- Use full words, not abbreviations\n- Be consistent with Scheme stdlib naming\n\n**Formatting:**\n- Indent consistently (2 spaces per level)\n- Align closing parens vertically\n- Break long expressions across lines\n- Group related functions together\n\n---\n\n## 7. Use Appropriate Abstraction Levels\n\nHigher-order functions, closures, macros - use when they improve clarity:\n\n```scheme\n;; Good: clear intent with higher-order function\n(filter (lambda (x) (> x 0)) numbers)\n\n;; Overkill: macro where function suffices\n(define-syntax when-positive  ; Don't do this for simple case\n  (syntax-rules ()\n    ((when-positive x body ...)\n     (if (> x 0) (begin body ...)))))\n```\n\n**Abstraction ladder:**\n\n1. **Direct code**: Simplest, most explicit\n2. **Helper functions**: Reduce duplication\n3. **Higher-order functions**: Parameterize behavior\n4. **Macros**: Create new syntax (use sparingly!)\n\n**When to create abstractions:**\n- Pattern appears 3+ times\n- Logic is complex and benefits from naming\n- Future changes will be localized\n\n**When NOT to abstract:**\n- One-off code\n- Abstraction obscures intent\n- Too early (wait for real duplication)\n\n---\n\n## 8. Mind Performance When Needed\n\n- Use tail recursion to avoid stack growth\n- Avoid quadratic operations (repeated `append`)\n- Consider compilation for frequently-run code\n- Profile before optimizing\n\n```scheme\n;; Slow: O(nÂ²) with repeated append\n(let loop ((items input) (result '()))\n  (if (null? items)\n      result\n      (loop (cdr items) (append result (list (car items))))))\n\n;; Fast: O(n) with cons + reverse\n(reverse\n  (let loop ((items input) (result '()))\n    (if (null? items)\n        result\n        (loop (cdr items) (cons (car items) result)))))\n```\n\n**Common performance pitfalls:**\n- `append` on right side of list (O(n) per call)\n- Deep recursion without tail calls (stack overflow)\n- String concatenation in loops (use `string-append` with list, then join)\n- Repeated `length` calls (cache it if needed)\n\n**Optimization strategy:**\n\n1. Write correct code first\n2. Measure if performance matters\n3. Identify bottlenecks (profiling)\n4. Apply targeted optimizations\n5. Verify correctness still holds\n\n---\n\n## 9. Follow Scheme Conventions\n\nEven with Guile-specific features, stick to Scheme idioms:\n\n**Lexical scope:**\n- Use `let`, `let*`, `letrec` appropriately\n- `let`: bindings don't see each other\n- `let*`: sequential bindings (can reference earlier ones)\n- `letrec`: recursive bindings\n\n**Immutability:**\n- Default to immutable data structures\n- Return new values instead of mutating\n- Use `!` suffix only when truly necessary\n\n**Proper tail calls:**\n- Scheme guarantees tail call optimization\n- Rely on it for iteration\n- No need for explicit loops (unless clearer)\n\n**Closures:**\n- Capture environment for encapsulation\n- Create stateful objects functionally\n- Return functions from functions\n\n---\n\n## 10. Handle Errors Gracefully\n\nProvide helpful error messages with context:\n\n```scheme\n;; Bad: generic error\n(if (not (file-exists? config-file))\n    (error \"File not found\"))\n\n;; Good: specific context\n(if (not (file-exists? config-file))\n    (error (format #f \"Config file not found: ~a\\nExpected at: ~a\"\n                   config-file\n                   (dirname config-file))))\n```\n\n**Error handling strategies:**\n\n**Guard against invalid input:**\n```scheme\n(define (divide a b)\n  (if (zero? b)\n      (error \"Cannot divide by zero\")\n      (/ a b)))\n```\n\n**Validate early:**\n```scheme\n(define (process-config filepath)\n  ;; Validate upfront\n  (unless (file-exists? filepath)\n    (error (format #f \"Config not found: ~a\" filepath)))\n  (unless (access? filepath R_OK)\n    (error (format #f \"Config not readable: ~a\" filepath)))\n\n  ;; Now process\n  ...)\n```\n\n**Provide recovery options:**\n```scheme\n(define (safe-read-config filepath fallback)\n  (if (file-exists? filepath)\n      (call-with-input-file filepath read)\n      fallback))\n```\n\n---\n\n## Resources\n\n### Recommended Learning Resources\n\n#### 1. [Guile Reference Manual - \"Programming in Scheme\"](https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme)\n**The official manual** for Guile, covering how to use it interactively, scripting, modules, debugging, etc.\n\n**Why useful:** Gives you the \"what\" of Guile and how to use the language in practice (not just theory).\n\n**Tip:** Use this as your baseline reference. Whenever you're unsure how to structure a module, script, or use a particular part of the API â€” go here.\n\n#### 2. [The Guile Hacker's Notebook](https://jeko.frama.io/)\nA resource dedicated specifically to Guile: covers concrete programming situations and brings best-practice thinking (TDD, clean code, architecture) into Scheme/Guile.\n\n**Why useful:** Covers how to write maintainable code in Guile, not just syntax.\n\n**Tip:** As you advance from basic syntax into \"how to write maintainable code in Guile\", this is very helpful.\n\n#### 3. [Andy Wingo's Blog: \"Wingolog\"](https://wingolog.org/)\nBlog posts and talks by a Guile maintainer. For example: [\"Lessons Learned from Guile, the Ancient & Spry\"](https://wingolog.org/archives/2016/01/11/lessons-learned-from-guile-the-ancient-and-spry)\n\n**Why useful:** Meta-level thinking about how Guile is built and evolves - informs design decisions and best practices.\n\n**Tip:** Use this for understanding \"why\" Guile works the way it does, which helps you make better architecture/style choices.\n\n#### 4. [System Crafters Community Discussions](https://systemcrafters.net/)\nCommunity discussions like \"Is there a good learning material on Guile Scheme?\"\n\n**Why useful:** Honest user reflections - what they found difficult, what worked, common gotchas.\n\n**Tip:** Browse these to see common patterns and pitfalls (especially with modules, REPL, embedding).\n\n### Official Documentation\n- [Guile Manual](https://www.gnu.org/software/guile/manual/)\n- [SRFI-1 List Library](https://srfi.schemers.org/srfi-1/srfi-1.html)\n- [Guix Manual](https://guix.gnu.org/manual/)\n\n### Quick References\n- Pattern matching: [ice-9 match](https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html)\n- File I/O: [Ports and File Descriptors](https://www.gnu.org/software/guile/manual/html_node/File-Ports.html)\n- Pretty-printing: [ice-9 pretty-print](https://www.gnu.org/software/guile/manual/html_node/Pretty_002dPrinting.html)\n- Tail calls: [Expressions](https://www.gnu.org/software/guile/manual/html_node/Expressions.html)\n- Modules: [Modules](https://www.gnu.org/software/guile/manual/html_node/Modules.html)\n\n### Performance and Optimization\n- [David Thompson: Optimizing Guile](https://dthompson.us/posts/optimize-guile.html)\n- Guile compilation, bytecode, and performance considerations\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted best practices from GUILE_KNOWLEDGE.md\n- Organized into 10 thematic sections\n- Added practical examples for each principle\n- Included learning resources and references\n\n---\n\n# Guile/Scheme Gotchas and Common Mistakes\n\nThis document tracks mistakes we've actually made during development, sorted by frequency.\n\n**Format**: Each gotcha includes:\n- **Count**: Number of times we've hit this issue (kept up-to-date)\n- **The Mistake**: What we did wrong\n- **Why It Failed**: Technical explanation\n- **The Fix**: Correct approach\n- **When to Watch For**: Situations where this mistake is likely\n\n---\n\n## Gotcha Leaderboard (Sorted by Frequency)\n\n### [Count: 3] Missing SRFI-1 Import\n\n**The Mistake:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match))\n\n;; Later in code:\n(let ((filtered (filter-map some-fn items)))  ; ERROR!\n  ...)\n```\n\n**Why It Failed:**\n```\nERROR: Unbound variable: filter-map\n```\n\nList processing functions like `filter-map`, `fold`, `take`, `take-right`, etc. are not part of core Guile - they come from SRFI-1.\n\n**The Fix:**\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (srfi srfi-1))  ; REQUIRED for list functions\n```\n\n**When to Watch For:**\n- Using any list function beyond basic `car`, `cdr`, `cons`, `append`\n- Processing collections with `filter-map`, `fold`, `partition`\n- Taking slices with `take`, `drop`, `take-right`, `drop-right`\n\n**Frequency Notes:**\n- 2024-11-14: Initial occurrence (guile-config-helper.scm)\n- 2024-11-14: bootstrap-postinstall.scm (take/take-right)\n- 2024-11-15: Future occurrence tracking starts here\n\n---\n\n### [Count: 2] Wrong Shebang for Piped Execution\n\n**The Mistake:**\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\nWhen piped: `curl ... | guile`\n\n**Why It Failed:**\n```\n;;; In procedure primitive-load:\n;;; No such file or directory: \"/home/durant/-\"\n```\n\nThe `-s` flag tells Guile to expect a script filename argument. When piped, leftover `-` from arguments gets interpreted as a file path.\n\n**The Fix:**\n```scheme\n#!/run/current-system/profile/bin/guile \\\n--no-auto-compile\n!#\n```\n\n**When to Watch For:**\n- Creating scripts meant to be piped via curl\n- Scripts that should read from stdin\n- Bootstrap/installer scripts\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm initial shebang\n- 2024-11-15: Fixed by removing -s flag\n\n---\n\n### [Count: 2] Using macOS Commands on Guix\n\n**The Mistake:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"shasum -a 256 ~s\" filepath)))\n         ...))\n```\n\n**Why It Failed:**\n```\n/gnu/store/.../bash: line 1: shasum: command not found\n```\n\n`shasum` is a BSD/macOS tool. Guix systems use GNU coreutils which provides `sha256sum`.\n\n**The Fix:**\n```scheme\n(define (file-sha256 filepath)\n  (let* ((port (open-input-pipe (format #f \"sha256sum ~s\" filepath)))\n         ...))\n```\n\n**When to Watch For:**\n- Porting scripts from macOS development to Guix deployment\n- Using BSD-specific commands: `shasum`, `md5`, `gstat`, etc.\n- Always use GNU coreutils equivalents: `sha256sum`, `md5sum`, `stat`\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm checksum function\n- 2024-11-15: Will likely happen again when porting more scripts\n\n---\n\n### [Count: 1] Reading Only First S-expression\n\n**The Mistake:**\n```scheme\n(define (read-config filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (read port))))  ; ONLY READS FIRST FORM!\n```\n\n**Why It Failed:**\nGuix config files have multiple top-level S-expressions:\n```scheme\n(use-modules (gnu))  ; First form\n(use-modules (gnu services networking))  ; Second form\n(operating-system ...)  ; Third form\n```\n\nOnly got `(use-modules (gnu))`, missing the rest!\n\n**The Fix:**\n```scheme\n(define (read-all-exprs filepath)\n  (call-with-input-file filepath\n    (lambda (port)\n      (let loop ((exprs '()))\n        (let ((expr (read port)))\n          (if (eof-object? expr)\n              (reverse exprs)\n              (loop (cons expr exprs))))))))\n```\n\n**When to Watch For:**\n- Reading Guix config files (always have multiple use-modules + operating-system)\n- Processing Scheme files with multiple top-level definitions\n- Any file that's more than a single S-expression\n\n**Frequency Notes:**\n- 2024-11-14: guile-config-helper.scm initial implementation\n\n---\n\n### [Count: 1] Wrong Invocation for Piped Scripts\n\n**The Mistake:**\n```bash\ncurl ... | guile --no-auto-compile -s -\n```\n\n**Why It Failed:**\nThe `-s -` combination causes Guile to look for a script file named `-`, leading to path resolution errors.\n\n**The Fix:**\n```bash\ncurl ... | guile\n```\n\nWith the correct shebang (backslash continuation, no `-s`), Guile reads from stdin automatically.\n\n**When to Watch For:**\n- One-liner bootstrap commands\n- Documentation examples for piped execution\n- CI/CD scripts that download and run Guile code\n\n**Frequency Notes:**\n- 2024-11-15: bootstrap-postinstall.scm documentation\n\n---\n\n## Changelog\n\n### 2024-11-15: Initial Creation\n- Extracted gotchas from GUILE_KNOWLEDGE.md\n- Established frequency tracking system\n- Sorted by count (highest first)\n- Added 5 initial gotchas with counts\n\n### Frequency Tracking Protocol\n\nWhen you encounter a gotcha:\n\n1. **If it's already listed**: Increment the count, add date note\n2. **If it's new**: Add it with `[Count: 1]`, insert in sorted position\n3. **Periodically re-sort**: Keep highest-frequency gotchas at top\n4. **Update notes**: Add specific occurrence details to help identify patterns\n\nThis ensures the most common mistakes are always visible first!\n\n---\n\n# Guile Conversion Plan\n\n## Overview\n\nWe're systematically converting all shell scripts that run on Guix systems to Guile Scheme. This provides:\n\n- **Proper S-expression handling** for config.scm manipulation\n- **Type safety** and better error handling\n- **Consistency** with Guix's native language\n- **Maintainability** through structured code\n- **Future-proofing** for advanced Guix features\n\n## Conversion Strategy\n\n### Phase 1: Library Infrastructure (COMPLETED)\n- âœ… Created `lib/guile-config-helper.scm` for S-expression manipulation\n- âœ… Set up Guile testing in Docker\n- âœ… Created test framework in `lib/tests/`\n- âœ… Verified Guile integration with existing Go/shell tests\n\n### Phase 2: Postinstall Scripts (IN PROGRESS)\nConvert postinstall customization scripts to use Guile helper:\n\n1. Update `framework-dual/postinstall/customize` to use Guile helper\n2. Create similar for other platforms\n3. Test GNOME, NetworkManager, SSH configurations\n\n### Phase 3: Critical Installation Scripts (PLANNED)\nConvert lib/*.sh scripts to Guile:\n\nPriority order (by complexity and criticality):\n\n1. **lib/postinstall.sh** (744B) - Simplest, good starting point\n   - Channel generation utilities\n   - Used by customize scripts\n\n2. **lib/clean-install.sh** (3.0K) - Medium complexity\n   - Clean installation wrapper\n   - Calls into Go installer\n\n3. **lib/verify-guix-install.sh** (8.2K) - Complex verification\n   - Post-install verification\n   - System checks\n\n4. **lib/bootstrap-installer.sh** (7.6K) - Bootstrap logic\n   - Downloads and verifies repo\n   - Builds Go installer\n\n5. **lib/recovery-complete-install.sh** (13K) - Most complex\n   - Recovery scenarios\n   - Multiple installation paths\n\n6. **lib/channel-utils.sh** (6.8K) - Channel management\n   - Mirror selection\n   - Channel configuration\n\n### Phase 4: Integration and Testing\n- Update all platform READMEs\n- Create comprehensive Guile test suite\n- Docker testing for all conversions\n- Update documentation\n\n## Conversion Guidelines\n\n### Shebang for Guile Scripts on Guix\n```scheme\n#!/run/current-system/profile/bin/guile --no-auto-compile -s\n!#\n```\n\n### Module Structure\n```scheme\n(use-modules (ice-9 pretty-print)\n             (ice-9 match)\n             (ice-9 rdelim)\n             (srfi srfi-1)\n             (srfi srfi-26))  ; cut/cute for partial application\n```\n\n### Common Patterns\n\n#### Bash â†’ Guile\n\n**Command execution:**\n```bash\n# Bash\noutput=$(command arg1 arg2)\nif [ $? -eq 0 ]; then\n    echo \"Success\"\nfi\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 popen) (ice-9 rdelim))\n\n(let* ((port (open-input-pipe \"command arg1 arg2\"))\n       (output (read-string port))\n       (status (close-pipe port)))\n  (if (zero? status)\n      (display \"Success\\n\")))\n```\n\n**File operations:**\n```bash\n# Bash\nif [ -f \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n```\n\n```scheme\n;; Guile\n(when (file-exists? file)\n  (let ((content (call-with-input-file file read-string)))\n    ...))\n```\n\n**Argument parsing:**\n```bash\n# Bash\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --flag) FLAG=true; shift ;;\n        *) ARG=$1; shift ;;\n    esac\ndone\n```\n\n```scheme\n;; Guile\n(use-modules (ice-9 getopt-long))\n\n(define option-spec\n  '((flag (single-char #\\f) (value #f))\n    (arg (single-char #\\a) (value #t))))\n\n(let ((options (getopt-long (command-line) option-spec)))\n  (define flag (option-ref options 'flag #f))\n  (define arg (option-ref options 'arg #f))\n  ...)\n```\n\n## Testing Requirements\n\nEach converted script must have:\n\n1. **Unit tests** in `lib/tests/test-<script-name>.scm`\n2. **Integration tests** verifying behavior matches bash version\n3. **Docker tests** ensuring Guile dependencies are available\n4. **Documentation** explaining any behavior changes\n\n## Status Tracking\n\n| Script | Lines | Status | Tests | Notes |\n|--------|-------|--------|-------|-------|\n| guile-config-helper.scm | 169 | âœ… Done | âœ… Passing | S-expression manipulation |\n| postinstall.sh | 31 | ðŸ”„ Next | â¸ï¸ Pending | Channel utilities |\n| clean-install.sh | 134 | â¸ï¸ Planned | â¸ï¸ Pending | Installation wrapper |\n| verify-guix-install.sh | 305 | â¸ï¸ Planned | â¸ï¸ Pending | Verification checks |\n| bootstrap-installer.sh | 267 | â¸ï¸ Planned | â¸ï¸ Pending | Bootstrap logic |\n| recovery-complete-install.sh | 458 | â¸ï¸ Planned | â¸ï¸ Pending | Recovery flows |\n| channel-utils.sh | 235 | â¸ï¸ Planned | â¸ï¸ Pending | Channel/mirror selection |\n\n## Migration Path\n\nFor each script:\n\n1. **Analyze** - Understand current bash implementation\n2. **Design** - Plan Guile equivalent with better structure\n3. **Implement** - Write .scm version alongside .sh\n4. **Test** - Comprehensive testing in Docker + real Guix\n5. **Document** - Update all references and docs\n6. **Deploy** - Switch references from .sh to .scm\n7. **Deprecate** - Mark .sh as deprecated\n8. **Remove** - Delete .sh after stable period\n\n## Notes\n\n- **Coexistence**: .sh and .scm versions will coexist during transition\n- **Testing**: Both versions tested until .scm proven stable\n- **Rollback**: Keep .sh versions until all platforms verified\n- **Knowledge Base**: See [GUILE_KNOWLEDGE.md](GUILE_KNOWLEDGE.md) for lessons learned and best practices\n- **Read First**: Review GUILE_KNOWLEDGE.md before starting any Guile development work\n\n\n---\n\nORIGINAL SCRIPT PATH: postinstall/recipes/add-vanilla-emacs.sh\n\nORIGINAL SCRIPT CONTENT:\n\n#!/usr/bin/env bash\n# Shared recipe: Install vanilla Emacs with minimal configuration\n# Can be called from any platform's customize tool\n\nset -euo pipefail\n\nCONFIG_FILE=\"${CONFIG_FILE:-/etc/config.scm}\"\n\n# Colors\ninfo() { printf \"  %s\\n\" \"$*\"; }\nwarn() { printf \"\\n\\033[1;33m[warn]\\033[0m %s\\n\" \"$*\"; }\nsuccess() { printf \"\\n\\033[1;32m[OK]\\033[0m %s\\n\" \"$*\"; }\n\nadd_vanilla_emacs() {\n  echo \"\"\n  echo \"=== Installing Vanilla Emacs ===\"\n  echo \"\"\n\n  # Check if Emacs is already installed\n  if ! grep -q \"emacs\" \"$CONFIG_FILE\"; then\n    info \"Adding Emacs package to config.scm...\"\n\n    # Add package modules if not present\n    if ! grep -q \"gnu packages emacs\" \"$CONFIG_FILE\"; then\n      sed -i '/(use-modules/a\\             (gnu packages emacs)\\n             (gnu packages version-control))' \"$CONFIG_FILE\"\n    fi\n\n    # Add emacs to packages\n    if grep -q \"(packages %base-packages)\" \"$CONFIG_FILE\"; then\n      # Minimal config - expand to use append\n      sed -i 's|(packages %base-packages)|(packages\\n  (append\\n   (list emacs\\n         git)\\n   %base-packages))|' \"$CONFIG_FILE\"\n    else\n      # Already has packages list, add to it\n      sed -i '/(packages/,/))/ { /list/ { s/list/list emacs\\n         git/ } }' \"$CONFIG_FILE\"\n    fi\n\n    info \"Emacs added to configuration\"\n  else\n    info \"Emacs already in configuration\"\n  fi\n\n  # Ask if user wants to import existing config\n  echo \"\"\n  read -r -p \"Do you have an existing vanilla Emacs config to import? [y/N] \" import_config </dev/tty\n\n  if [[ \"$import_config\" =~ ^[Yy]$ ]]; then\n    echo \"\"\n    info \"Import options:\"\n    info \"  1. Git repository URL (for .emacs.d or init.el)\"\n    info \"  2. Skip import (install fresh, import manually later)\"\n    echo \"\"\n    read -r -p \"Enter choice [1-2]: \" choice </dev/tty\n\n    case \"$choice\" in\n      1)\n        read -r -p \"Enter Git repository URL (e.g., https://github.com/user/emacs-config): \" repo_url </dev/tty\n        if [[ -n \"$repo_url\" ]]; then\n          info \"Will import config from: $repo_url\"\n          IMPORT_EMACS_CONFIG=\"$repo_url\"\n        else\n          warn \"No URL provided, will create default config\"\n        fi\n        ;;\n      2)\n        info \"Skipping import - you can manually import later\"\n        info \"See: ~/guix-customize/EMACS_IMPORT_GUIDE.md\"\n        ;;\n      *)\n        warn \"Invalid choice, will create default config\"\n        ;;\n    esac\n  fi\n\n  # Import user's config or create minimal configuration\n  if [[ -n \"$IMPORT_EMACS_CONFIG\" ]]; then\n    info \"Importing your Emacs configuration...\"\n\n    if [[ -d \"$HOME/.emacs.d\" ]] || [[ -f \"$HOME/.emacs\" ]]; then\n      warn \"Existing Emacs configuration found\"\n      read -r -p \"Backup and replace with imported config? [y/N] \" ans </dev/tty\n      if [[ \"$ans\" =~ ^[Yy]$ ]]; then\n        [[ -d \"$HOME/.emacs.d\" ]] && mv \"$HOME/.emacs.d\" \"$HOME/.emacs.d.backup.$(date +%Y%m%d-%H%M%S)\"\n        [[ -f \"$HOME/.emacs\" ]] && mv \"$HOME/.emacs\" \"$HOME/.emacs.backup.$(date +%Y%m%d-%H%M%S)\"\n        info \"Backed up existing Emacs configuration\"\n      else\n        info \"Keeping existing configuration\"\n        return 0\n      fi\n    fi\n\n    if git clone \"$IMPORT_EMACS_CONFIG\" \"$HOME/.emacs.d\"; then\n      success \"Emacs config imported successfully!\"\n    else\n      warn \"Failed to clone repository, creating default config instead\"\n      IMPORT_EMACS_CONFIG=\"\"\n    fi\n  fi\n\n  # Create minimal config if not imported\n  if [[ -z \"$IMPORT_EMACS_CONFIG\" ]]; then\n    info \"Creating minimal Emacs configuration...\"\n\n    if [[ -d \"$HOME/.emacs.d\" ]] || [[ -f \"$HOME/.emacs\" ]]; then\n      warn \"Existing Emacs configuration found\"\n      read -r -p \"Backup and create minimal config? [y/N] \" ans </dev/tty\n      if [[ \"$ans\" =~ ^[Yy]$ ]]; then\n        [[ -d \"$HOME/.emacs.d\" ]] && mv \"$HOME/.emacs.d\" \"$HOME/.emacs.d.backup.$(date +%Y%m%d-%H%M%S)\"\n        [[ -f \"$HOME/.emacs\" ]] && mv \"$HOME/.emacs\" \"$HOME/.emacs.backup.$(date +%Y%m%d-%H%M%S)\"\n        info \"Backed up existing Emacs configuration\"\n      else\n        info \"Keeping existing configuration\"\n        return 0\n      fi\n    fi\n\n    # Create init.el with sensible defaults\n    mkdir -p \"$HOME/.emacs.d\"\n  cat > \"$HOME/.emacs.d/init.el\" <<'EOF'\n;;; init.el --- Minimal Emacs configuration -*- lexical-binding: t -*-\n\n;;; Commentary:\n;; A minimal Emacs configuration with sensible defaults\n\n;;; Code:\n\n;; Performance tweaks\n(setq gc-cons-threshold 100000000)\n(setq read-process-output-max (* 1024 1024))\n\n;; Package management\n(require 'package)\n(setq package-archives '((\"melpa\" . \"https://melpa.org/packages/\")\n                          (\"gnu\" . \"https://elpa.gnu.org/packages/\")))\n(package-initialize)\n\n;; UI improvements\n(setq inhibit-startup-message t)\n(tool-bar-mode -1)\n(menu-bar-mode -1)\n(scroll-bar-mode -1)\n(column-number-mode t)\n(show-paren-mode t)\n(global-hl-line-mode t)\n\n;; Line numbers\n(global-display-line-numbers-mode t)\n(setq display-line-numbers-type 'relative)\n\n;; Better defaults\n(setq-default indent-tabs-mode nil)\n(setq-default tab-width 4)\n(setq require-final-newline t)\n(setq visible-bell t)\n(setq ring-bell-function 'ignore)\n(setq backup-directory-alist '((\".\" . \"~/.emacs.d/backups\")))\n(setq auto-save-file-name-transforms '((\".*\" \"~/.emacs.d/auto-save-list/\" t)))\n\n;; Recent files\n(recentf-mode 1)\n(setq recentf-max-menu-items 25)\n(setq recentf-max-saved-items 25)\n\n;; IDO mode for better file/buffer switching\n(ido-mode 1)\n(ido-everywhere 1)\n(setq ido-enable-flex-matching t)\n\n;; Electric pair mode\n(electric-pair-mode 1)\n\n;; Whitespace cleanup\n(add-hook 'before-save-hook 'whitespace-cleanup)\n\n;; Custom key bindings\n(global-set-key (kbd \"C-x C-b\") 'ibuffer)\n(global-set-key (kbd \"M-/\") 'hippie-expand)\n\n;; Theme (built-in)\n(load-theme 'wombat t)\n\n;; Custom file\n(setq custom-file (expand-file-name \"custom.el\" user-emacs-directory))\n(when (file-exists-p custom-file)\n  (load custom-file))\n\n;;; init.el ends here\nEOF\n  fi\n\n  success \"Vanilla Emacs configuration created!\"\n  echo \"\"\n  info \"Next steps:\"\n  info \"  1. Apply config: sudo guix system reconfigure /etc/config.scm\"\n  info \"  2. Launch Emacs to start using it\"\n  if [[ -z \"$IMPORT_EMACS_CONFIG\" ]]; then\n    info \"  3. Customize ~/.emacs.d/init.el as needed\"\n  fi\n  echo \"\"\n  info \"Basic Emacs commands:\"\n  info \"  C-x C-f - Find file\"\n  info \"  C-x C-s - Save file\"\n  info \"  C-x b   - Switch buffer\"\n  info \"  C-x 2   - Split window horizontally\"\n  info \"  C-x 3   - Split window vertically\"\n  info \"  C-x 1   - Close other windows\"\n  info \"  C-x C-c - Quit Emacs\"\n  echo \"\"\n  if [[ -z \"$IMPORT_EMACS_CONFIG\" ]]; then\n    info \"To add packages:\"\n    info \"  M-x package-list-packages\"\n    info \"  i (mark), x (install), d (mark delete)\"\n    echo \"\"\n    info \"To import your config later, see: ~/guix-customize/EMACS_IMPORT_GUIDE.md\"\n  fi\n  echo \"\"\n}\n\n# Run if called directly\nif [[ \"${BASH_SOURCE[0]}\" == \"${0}\" ]]; then\n  add_vanilla_emacs\nfi\n\n\n---\n\nCONVERSION REQUIREMENTS:\n\n1. Use proper Guile shebang: #!/run/current-system/profile/bin/guile --no-auto-compile -s\n2. Include all necessary use-modules (ice-9 popen, ice-9 rdelim, ice-9 format, srfi srfi-1)\n3. Convert all bash functions to Guile procedures\n4. Use Guile idioms: call-with-input-file, open-input-pipe, etc.\n5. Maintain all functionality from the original script\n6. Add comments explaining complex conversions\n7. Follow naming conventions: predicates end in ?, mutators end in !\n8. Use tail recursion where appropriate\n9. Use GNU coreutils commands (sha256sum not shasum, etc.)\n\nOUTPUT FORMAT:\n\nProvide ONLY the complete converted Guile script. No explanations, no markdown formatting, just the raw .scm file content starting with the shebang.\n"
      }
    ]
  }
}

